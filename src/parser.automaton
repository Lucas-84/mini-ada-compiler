State 0:
file' -> . file [ # ]
-- On WITH shift to state 1
-- On file shift to state 204

State 1:
file -> WITH . STDLIB SEMICOLON USE STDLIB SEMICOLON PROCEDURE IDENT IS list(decl) BEGIN nonempty_list(stmt) END option(IDENT) SEMICOLON EOF [ # ]
-- On STDLIB shift to state 2

State 2:
file -> WITH STDLIB . SEMICOLON USE STDLIB SEMICOLON PROCEDURE IDENT IS list(decl) BEGIN nonempty_list(stmt) END option(IDENT) SEMICOLON EOF [ # ]
-- On SEMICOLON shift to state 3

State 3:
file -> WITH STDLIB SEMICOLON . USE STDLIB SEMICOLON PROCEDURE IDENT IS list(decl) BEGIN nonempty_list(stmt) END option(IDENT) SEMICOLON EOF [ # ]
-- On USE shift to state 4

State 4:
file -> WITH STDLIB SEMICOLON USE . STDLIB SEMICOLON PROCEDURE IDENT IS list(decl) BEGIN nonempty_list(stmt) END option(IDENT) SEMICOLON EOF [ # ]
-- On STDLIB shift to state 5

State 5:
file -> WITH STDLIB SEMICOLON USE STDLIB . SEMICOLON PROCEDURE IDENT IS list(decl) BEGIN nonempty_list(stmt) END option(IDENT) SEMICOLON EOF [ # ]
-- On SEMICOLON shift to state 6

State 6:
file -> WITH STDLIB SEMICOLON USE STDLIB SEMICOLON . PROCEDURE IDENT IS list(decl) BEGIN nonempty_list(stmt) END option(IDENT) SEMICOLON EOF [ # ]
-- On PROCEDURE shift to state 7

State 7:
file -> WITH STDLIB SEMICOLON USE STDLIB SEMICOLON PROCEDURE . IDENT IS list(decl) BEGIN nonempty_list(stmt) END option(IDENT) SEMICOLON EOF [ # ]
-- On IDENT shift to state 8

State 8:
file -> WITH STDLIB SEMICOLON USE STDLIB SEMICOLON PROCEDURE IDENT . IS list(decl) BEGIN nonempty_list(stmt) END option(IDENT) SEMICOLON EOF [ # ]
-- On IS shift to state 9

State 9:
file -> WITH STDLIB SEMICOLON USE STDLIB SEMICOLON PROCEDURE IDENT IS . list(decl) BEGIN nonempty_list(stmt) END option(IDENT) SEMICOLON EOF [ # ]
-- On TYPE shift to state 10
-- On PROCEDURE shift to state 34
-- On IDENT shift to state 15
-- On FUNCTION shift to state 52
-- On separated_nonempty_list(COMMA,IDENT) shift to state 58
-- On list(decl) shift to state 197
-- On decl shift to state 189
-- On BEGIN reduce production list(decl) -> 

State 10:
decl -> TYPE . IDENT SEMICOLON [ TYPE PROCEDURE IDENT FUNCTION BEGIN ]
decl -> TYPE . IDENT IS ACCESS IDENT SEMICOLON [ TYPE PROCEDURE IDENT FUNCTION BEGIN ]
decl -> TYPE . IDENT IS RECORD nonempty_list(field) END RECORD SEMICOLON [ TYPE PROCEDURE IDENT FUNCTION BEGIN ]
-- On IDENT shift to state 11

State 11:
decl -> TYPE IDENT . SEMICOLON [ TYPE PROCEDURE IDENT FUNCTION BEGIN ]
decl -> TYPE IDENT . IS ACCESS IDENT SEMICOLON [ TYPE PROCEDURE IDENT FUNCTION BEGIN ]
decl -> TYPE IDENT . IS RECORD nonempty_list(field) END RECORD SEMICOLON [ TYPE PROCEDURE IDENT FUNCTION BEGIN ]
-- On SEMICOLON shift to state 12
-- On IS shift to state 13

State 12:
decl -> TYPE IDENT SEMICOLON . [ TYPE PROCEDURE IDENT FUNCTION BEGIN ]
-- On TYPE reduce production decl -> TYPE IDENT SEMICOLON 
-- On PROCEDURE reduce production decl -> TYPE IDENT SEMICOLON 
-- On IDENT reduce production decl -> TYPE IDENT SEMICOLON 
-- On FUNCTION reduce production decl -> TYPE IDENT SEMICOLON 
-- On BEGIN reduce production decl -> TYPE IDENT SEMICOLON 

State 13:
decl -> TYPE IDENT IS . ACCESS IDENT SEMICOLON [ TYPE PROCEDURE IDENT FUNCTION BEGIN ]
decl -> TYPE IDENT IS . RECORD nonempty_list(field) END RECORD SEMICOLON [ TYPE PROCEDURE IDENT FUNCTION BEGIN ]
-- On RECORD shift to state 14
-- On ACCESS shift to state 31

State 14:
decl -> TYPE IDENT IS RECORD . nonempty_list(field) END RECORD SEMICOLON [ TYPE PROCEDURE IDENT FUNCTION BEGIN ]
-- On IDENT shift to state 15
-- On separated_nonempty_list(COMMA,IDENT) shift to state 18
-- On nonempty_list(field) shift to state 25
-- On field shift to state 29

State 15:
separated_nonempty_list(COMMA,IDENT) -> IDENT . [ COLON ]
separated_nonempty_list(COMMA,IDENT) -> IDENT . COMMA separated_nonempty_list(COMMA,IDENT) [ COLON ]
-- On COMMA shift to state 16
-- On COLON reduce production separated_nonempty_list(COMMA,IDENT) -> IDENT 

State 16:
separated_nonempty_list(COMMA,IDENT) -> IDENT COMMA . separated_nonempty_list(COMMA,IDENT) [ COLON ]
-- On IDENT shift to state 15
-- On separated_nonempty_list(COMMA,IDENT) shift to state 17

State 17:
separated_nonempty_list(COMMA,IDENT) -> IDENT COMMA separated_nonempty_list(COMMA,IDENT) . [ COLON ]
-- On COLON reduce production separated_nonempty_list(COMMA,IDENT) -> IDENT COMMA separated_nonempty_list(COMMA,IDENT) 

State 18:
field -> separated_nonempty_list(COMMA,IDENT) . COLON stype SEMICOLON [ IDENT END ]
-- On COLON shift to state 19

State 19:
field -> separated_nonempty_list(COMMA,IDENT) COLON . stype SEMICOLON [ IDENT END ]
-- On IDENT shift to state 20
-- On ACCESS shift to state 21
-- On stype shift to state 23

State 20:
stype -> IDENT . [ SEMICOLON RPAR IS COLONEQ ]
-- On SEMICOLON reduce production stype -> IDENT 
-- On RPAR reduce production stype -> IDENT 
-- On IS reduce production stype -> IDENT 
-- On COLONEQ reduce production stype -> IDENT 

State 21:
stype -> ACCESS . IDENT [ SEMICOLON RPAR IS COLONEQ ]
-- On IDENT shift to state 22

State 22:
stype -> ACCESS IDENT . [ SEMICOLON RPAR IS COLONEQ ]
-- On SEMICOLON reduce production stype -> ACCESS IDENT 
-- On RPAR reduce production stype -> ACCESS IDENT 
-- On IS reduce production stype -> ACCESS IDENT 
-- On COLONEQ reduce production stype -> ACCESS IDENT 

State 23:
field -> separated_nonempty_list(COMMA,IDENT) COLON stype . SEMICOLON [ IDENT END ]
-- On SEMICOLON shift to state 24

State 24:
field -> separated_nonempty_list(COMMA,IDENT) COLON stype SEMICOLON . [ IDENT END ]
-- On IDENT reduce production field -> separated_nonempty_list(COMMA,IDENT) COLON stype SEMICOLON 
-- On END reduce production field -> separated_nonempty_list(COMMA,IDENT) COLON stype SEMICOLON 

State 25:
decl -> TYPE IDENT IS RECORD nonempty_list(field) . END RECORD SEMICOLON [ TYPE PROCEDURE IDENT FUNCTION BEGIN ]
-- On END shift to state 26

State 26:
decl -> TYPE IDENT IS RECORD nonempty_list(field) END . RECORD SEMICOLON [ TYPE PROCEDURE IDENT FUNCTION BEGIN ]
-- On RECORD shift to state 27

State 27:
decl -> TYPE IDENT IS RECORD nonempty_list(field) END RECORD . SEMICOLON [ TYPE PROCEDURE IDENT FUNCTION BEGIN ]
-- On SEMICOLON shift to state 28

State 28:
decl -> TYPE IDENT IS RECORD nonempty_list(field) END RECORD SEMICOLON . [ TYPE PROCEDURE IDENT FUNCTION BEGIN ]
-- On TYPE reduce production decl -> TYPE IDENT IS RECORD nonempty_list(field) END RECORD SEMICOLON 
-- On PROCEDURE reduce production decl -> TYPE IDENT IS RECORD nonempty_list(field) END RECORD SEMICOLON 
-- On IDENT reduce production decl -> TYPE IDENT IS RECORD nonempty_list(field) END RECORD SEMICOLON 
-- On FUNCTION reduce production decl -> TYPE IDENT IS RECORD nonempty_list(field) END RECORD SEMICOLON 
-- On BEGIN reduce production decl -> TYPE IDENT IS RECORD nonempty_list(field) END RECORD SEMICOLON 

State 29:
nonempty_list(field) -> field . [ END ]
nonempty_list(field) -> field . nonempty_list(field) [ END ]
-- On IDENT shift to state 15
-- On separated_nonempty_list(COMMA,IDENT) shift to state 18
-- On nonempty_list(field) shift to state 30
-- On field shift to state 29
-- On END reduce production nonempty_list(field) -> field 

State 30:
nonempty_list(field) -> field nonempty_list(field) . [ END ]
-- On END reduce production nonempty_list(field) -> field nonempty_list(field) 

State 31:
decl -> TYPE IDENT IS ACCESS . IDENT SEMICOLON [ TYPE PROCEDURE IDENT FUNCTION BEGIN ]
-- On IDENT shift to state 32

State 32:
decl -> TYPE IDENT IS ACCESS IDENT . SEMICOLON [ TYPE PROCEDURE IDENT FUNCTION BEGIN ]
-- On SEMICOLON shift to state 33

State 33:
decl -> TYPE IDENT IS ACCESS IDENT SEMICOLON . [ TYPE PROCEDURE IDENT FUNCTION BEGIN ]
-- On TYPE reduce production decl -> TYPE IDENT IS ACCESS IDENT SEMICOLON 
-- On PROCEDURE reduce production decl -> TYPE IDENT IS ACCESS IDENT SEMICOLON 
-- On IDENT reduce production decl -> TYPE IDENT IS ACCESS IDENT SEMICOLON 
-- On FUNCTION reduce production decl -> TYPE IDENT IS ACCESS IDENT SEMICOLON 
-- On BEGIN reduce production decl -> TYPE IDENT IS ACCESS IDENT SEMICOLON 

State 34:
decl -> PROCEDURE . IDENT option(params) IS list(decl) BEGIN nonempty_list(stmt) END option(IDENT) SEMICOLON [ TYPE PROCEDURE IDENT FUNCTION BEGIN ]
-- On IDENT shift to state 35

State 35:
decl -> PROCEDURE IDENT . option(params) IS list(decl) BEGIN nonempty_list(stmt) END option(IDENT) SEMICOLON [ TYPE PROCEDURE IDENT FUNCTION BEGIN ]
-- On LPAR shift to state 36
-- On params shift to state 49
-- On option(params) shift to state 50
-- On IS reduce production option(params) -> 

State 36:
params -> LPAR . separated_nonempty_list(SEMICOLON,param) RPAR [ RETURN IS ]
-- On IDENT shift to state 15
-- On separated_nonempty_list(SEMICOLON,param) shift to state 37
-- On separated_nonempty_list(COMMA,IDENT) shift to state 39
-- On param shift to state 46

State 37:
params -> LPAR separated_nonempty_list(SEMICOLON,param) . RPAR [ RETURN IS ]
-- On RPAR shift to state 38

State 38:
params -> LPAR separated_nonempty_list(SEMICOLON,param) RPAR . [ RETURN IS ]
-- On RETURN reduce production params -> LPAR separated_nonempty_list(SEMICOLON,param) RPAR 
-- On IS reduce production params -> LPAR separated_nonempty_list(SEMICOLON,param) RPAR 

State 39:
param -> separated_nonempty_list(COMMA,IDENT) . COLON option(mode) stype [ SEMICOLON RPAR ]
-- On COLON shift to state 40

State 40:
param -> separated_nonempty_list(COMMA,IDENT) COLON . option(mode) stype [ SEMICOLON RPAR ]
-- On IN shift to state 41
-- On option(mode) shift to state 43
-- On mode shift to state 45
-- On IDENT reduce production option(mode) -> 
-- On ACCESS reduce production option(mode) -> 

State 41:
mode -> IN . OUT [ IDENT ACCESS ]
mode -> IN . [ IDENT ACCESS ]
-- On OUT shift to state 42
-- On IDENT reduce production mode -> IN 
-- On ACCESS reduce production mode -> IN 

State 42:
mode -> IN OUT . [ IDENT ACCESS ]
-- On IDENT reduce production mode -> IN OUT 
-- On ACCESS reduce production mode -> IN OUT 

State 43:
param -> separated_nonempty_list(COMMA,IDENT) COLON option(mode) . stype [ SEMICOLON RPAR ]
-- On IDENT shift to state 20
-- On ACCESS shift to state 21
-- On stype shift to state 44

State 44:
param -> separated_nonempty_list(COMMA,IDENT) COLON option(mode) stype . [ SEMICOLON RPAR ]
-- On SEMICOLON reduce production param -> separated_nonempty_list(COMMA,IDENT) COLON option(mode) stype 
-- On RPAR reduce production param -> separated_nonempty_list(COMMA,IDENT) COLON option(mode) stype 

State 45:
option(mode) -> mode . [ IDENT ACCESS ]
-- On IDENT reduce production option(mode) -> mode 
-- On ACCESS reduce production option(mode) -> mode 

State 46:
separated_nonempty_list(SEMICOLON,param) -> param . [ RPAR ]
separated_nonempty_list(SEMICOLON,param) -> param . SEMICOLON separated_nonempty_list(SEMICOLON,param) [ RPAR ]
-- On SEMICOLON shift to state 47
-- On RPAR reduce production separated_nonempty_list(SEMICOLON,param) -> param 

State 47:
separated_nonempty_list(SEMICOLON,param) -> param SEMICOLON . separated_nonempty_list(SEMICOLON,param) [ RPAR ]
-- On IDENT shift to state 15
-- On separated_nonempty_list(SEMICOLON,param) shift to state 48
-- On separated_nonempty_list(COMMA,IDENT) shift to state 39
-- On param shift to state 46

State 48:
separated_nonempty_list(SEMICOLON,param) -> param SEMICOLON separated_nonempty_list(SEMICOLON,param) . [ RPAR ]
-- On RPAR reduce production separated_nonempty_list(SEMICOLON,param) -> param SEMICOLON separated_nonempty_list(SEMICOLON,param) 

State 49:
option(params) -> params . [ RETURN IS ]
-- On RETURN reduce production option(params) -> params 
-- On IS reduce production option(params) -> params 

State 50:
decl -> PROCEDURE IDENT option(params) . IS list(decl) BEGIN nonempty_list(stmt) END option(IDENT) SEMICOLON [ TYPE PROCEDURE IDENT FUNCTION BEGIN ]
-- On IS shift to state 51

State 51:
decl -> PROCEDURE IDENT option(params) IS . list(decl) BEGIN nonempty_list(stmt) END option(IDENT) SEMICOLON [ TYPE PROCEDURE IDENT FUNCTION BEGIN ]
-- On TYPE shift to state 10
-- On PROCEDURE shift to state 34
-- On IDENT shift to state 15
-- On FUNCTION shift to state 52
-- On separated_nonempty_list(COMMA,IDENT) shift to state 58
-- On list(decl) shift to state 191
-- On decl shift to state 189
-- On BEGIN reduce production list(decl) -> 

State 52:
decl -> FUNCTION . IDENT option(params) RETURN stype IS list(decl) BEGIN nonempty_list(stmt) END option(IDENT) SEMICOLON [ TYPE PROCEDURE IDENT FUNCTION BEGIN ]
-- On IDENT shift to state 53

State 53:
decl -> FUNCTION IDENT . option(params) RETURN stype IS list(decl) BEGIN nonempty_list(stmt) END option(IDENT) SEMICOLON [ TYPE PROCEDURE IDENT FUNCTION BEGIN ]
-- On LPAR shift to state 36
-- On params shift to state 49
-- On option(params) shift to state 54
-- On RETURN reduce production option(params) -> 

State 54:
decl -> FUNCTION IDENT option(params) . RETURN stype IS list(decl) BEGIN nonempty_list(stmt) END option(IDENT) SEMICOLON [ TYPE PROCEDURE IDENT FUNCTION BEGIN ]
-- On RETURN shift to state 55

State 55:
decl -> FUNCTION IDENT option(params) RETURN . stype IS list(decl) BEGIN nonempty_list(stmt) END option(IDENT) SEMICOLON [ TYPE PROCEDURE IDENT FUNCTION BEGIN ]
-- On IDENT shift to state 20
-- On ACCESS shift to state 21
-- On stype shift to state 56

State 56:
decl -> FUNCTION IDENT option(params) RETURN stype . IS list(decl) BEGIN nonempty_list(stmt) END option(IDENT) SEMICOLON [ TYPE PROCEDURE IDENT FUNCTION BEGIN ]
-- On IS shift to state 57

State 57:
decl -> FUNCTION IDENT option(params) RETURN stype IS . list(decl) BEGIN nonempty_list(stmt) END option(IDENT) SEMICOLON [ TYPE PROCEDURE IDENT FUNCTION BEGIN ]
-- On TYPE shift to state 10
-- On PROCEDURE shift to state 34
-- On IDENT shift to state 15
-- On FUNCTION shift to state 52
-- On separated_nonempty_list(COMMA,IDENT) shift to state 58
-- On list(decl) shift to state 123
-- On decl shift to state 189
-- On BEGIN reduce production list(decl) -> 

State 58:
decl -> separated_nonempty_list(COMMA,IDENT) . COLON stype SEMICOLON [ TYPE PROCEDURE IDENT FUNCTION BEGIN ]
decl -> separated_nonempty_list(COMMA,IDENT) . COLON stype COLONEQ expr SEMICOLON [ TYPE PROCEDURE IDENT FUNCTION BEGIN ]
-- On COLON shift to state 59

State 59:
decl -> separated_nonempty_list(COMMA,IDENT) COLON . stype SEMICOLON [ TYPE PROCEDURE IDENT FUNCTION BEGIN ]
decl -> separated_nonempty_list(COMMA,IDENT) COLON . stype COLONEQ expr SEMICOLON [ TYPE PROCEDURE IDENT FUNCTION BEGIN ]
-- On IDENT shift to state 20
-- On ACCESS shift to state 21
-- On stype shift to state 60

State 60:
decl -> separated_nonempty_list(COMMA,IDENT) COLON stype . SEMICOLON [ TYPE PROCEDURE IDENT FUNCTION BEGIN ]
decl -> separated_nonempty_list(COMMA,IDENT) COLON stype . COLONEQ expr SEMICOLON [ TYPE PROCEDURE IDENT FUNCTION BEGIN ]
-- On SEMICOLON shift to state 61
-- On COLONEQ shift to state 62

State 61:
decl -> separated_nonempty_list(COMMA,IDENT) COLON stype SEMICOLON . [ TYPE PROCEDURE IDENT FUNCTION BEGIN ]
-- On TYPE reduce production decl -> separated_nonempty_list(COMMA,IDENT) COLON stype SEMICOLON 
-- On PROCEDURE reduce production decl -> separated_nonempty_list(COMMA,IDENT) COLON stype SEMICOLON 
-- On IDENT reduce production decl -> separated_nonempty_list(COMMA,IDENT) COLON stype SEMICOLON 
-- On FUNCTION reduce production decl -> separated_nonempty_list(COMMA,IDENT) COLON stype SEMICOLON 
-- On BEGIN reduce production decl -> separated_nonempty_list(COMMA,IDENT) COLON stype SEMICOLON 

State 62:
decl -> separated_nonempty_list(COMMA,IDENT) COLON stype COLONEQ . expr SEMICOLON [ TYPE PROCEDURE IDENT FUNCTION BEGIN ]
-- On TRUE shift to state 63
-- On SUB shift to state 64
-- On NULL shift to state 65
-- On NOT shift to state 66
-- On NEW shift to state 67
-- On LPAR shift to state 69
-- On INT shift to state 70
-- On IDENT shift to state 71
-- On FALSE shift to state 73
-- On CHARVAL shift to state 74
-- On CHAR shift to state 76
-- On expr shift to state 121
-- On access shift to state 84

State 63:
expr -> TRUE . [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
-- On THEN reduce production expr -> TRUE 
-- On SUB reduce production expr -> TRUE 
-- On SEMICOLON reduce production expr -> TRUE 
-- On RPAR reduce production expr -> TRUE 
-- On REM reduce production expr -> TRUE 
-- On OR reduce production expr -> TRUE 
-- On NEQ reduce production expr -> TRUE 
-- On MUL reduce production expr -> TRUE 
-- On LT reduce production expr -> TRUE 
-- On LOOP reduce production expr -> TRUE 
-- On LE reduce production expr -> TRUE 
-- On GT reduce production expr -> TRUE 
-- On GE reduce production expr -> TRUE 
-- On EQ reduce production expr -> TRUE 
-- On DOUBLEDOT reduce production expr -> TRUE 
-- On DOT reduce production expr -> TRUE 
-- On DIV reduce production expr -> TRUE 
-- On COMMA reduce production expr -> TRUE 
-- On AND reduce production expr -> TRUE 
-- On ADD reduce production expr -> TRUE 

State 64:
expr -> SUB . expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
-- On TRUE shift to state 63
-- On SUB shift to state 64
-- On NULL shift to state 65
-- On NOT shift to state 66
-- On NEW shift to state 67
-- On LPAR shift to state 69
-- On INT shift to state 70
-- On IDENT shift to state 71
-- On FALSE shift to state 73
-- On CHARVAL shift to state 74
-- On CHAR shift to state 76
-- On expr shift to state 120
-- On access shift to state 84

State 65:
expr -> NULL . [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
-- On THEN reduce production expr -> NULL 
-- On SUB reduce production expr -> NULL 
-- On SEMICOLON reduce production expr -> NULL 
-- On RPAR reduce production expr -> NULL 
-- On REM reduce production expr -> NULL 
-- On OR reduce production expr -> NULL 
-- On NEQ reduce production expr -> NULL 
-- On MUL reduce production expr -> NULL 
-- On LT reduce production expr -> NULL 
-- On LOOP reduce production expr -> NULL 
-- On LE reduce production expr -> NULL 
-- On GT reduce production expr -> NULL 
-- On GE reduce production expr -> NULL 
-- On EQ reduce production expr -> NULL 
-- On DOUBLEDOT reduce production expr -> NULL 
-- On DOT reduce production expr -> NULL 
-- On DIV reduce production expr -> NULL 
-- On COMMA reduce production expr -> NULL 
-- On AND reduce production expr -> NULL 
-- On ADD reduce production expr -> NULL 

State 66:
expr -> NOT . expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
-- On TRUE shift to state 63
-- On SUB shift to state 64
-- On NULL shift to state 65
-- On NOT shift to state 66
-- On NEW shift to state 67
-- On LPAR shift to state 69
-- On INT shift to state 70
-- On IDENT shift to state 71
-- On FALSE shift to state 73
-- On CHARVAL shift to state 74
-- On CHAR shift to state 76
-- On expr shift to state 119
-- On access shift to state 84

State 67:
expr -> NEW . IDENT [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
-- On IDENT shift to state 68

State 68:
expr -> NEW IDENT . [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
-- On THEN reduce production expr -> NEW IDENT 
-- On SUB reduce production expr -> NEW IDENT 
-- On SEMICOLON reduce production expr -> NEW IDENT 
-- On RPAR reduce production expr -> NEW IDENT 
-- On REM reduce production expr -> NEW IDENT 
-- On OR reduce production expr -> NEW IDENT 
-- On NEQ reduce production expr -> NEW IDENT 
-- On MUL reduce production expr -> NEW IDENT 
-- On LT reduce production expr -> NEW IDENT 
-- On LOOP reduce production expr -> NEW IDENT 
-- On LE reduce production expr -> NEW IDENT 
-- On GT reduce production expr -> NEW IDENT 
-- On GE reduce production expr -> NEW IDENT 
-- On EQ reduce production expr -> NEW IDENT 
-- On DOUBLEDOT reduce production expr -> NEW IDENT 
-- On DOT reduce production expr -> NEW IDENT 
-- On DIV reduce production expr -> NEW IDENT 
-- On COMMA reduce production expr -> NEW IDENT 
-- On AND reduce production expr -> NEW IDENT 
-- On ADD reduce production expr -> NEW IDENT 

State 69:
expr -> LPAR . expr RPAR [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
-- On TRUE shift to state 63
-- On SUB shift to state 64
-- On NULL shift to state 65
-- On NOT shift to state 66
-- On NEW shift to state 67
-- On LPAR shift to state 69
-- On INT shift to state 70
-- On IDENT shift to state 71
-- On FALSE shift to state 73
-- On CHARVAL shift to state 74
-- On CHAR shift to state 76
-- On expr shift to state 117
-- On access shift to state 84

State 70:
expr -> INT . [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
-- On THEN reduce production expr -> INT 
-- On SUB reduce production expr -> INT 
-- On SEMICOLON reduce production expr -> INT 
-- On RPAR reduce production expr -> INT 
-- On REM reduce production expr -> INT 
-- On OR reduce production expr -> INT 
-- On NEQ reduce production expr -> INT 
-- On MUL reduce production expr -> INT 
-- On LT reduce production expr -> INT 
-- On LOOP reduce production expr -> INT 
-- On LE reduce production expr -> INT 
-- On GT reduce production expr -> INT 
-- On GE reduce production expr -> INT 
-- On EQ reduce production expr -> INT 
-- On DOUBLEDOT reduce production expr -> INT 
-- On DOT reduce production expr -> INT 
-- On DIV reduce production expr -> INT 
-- On COMMA reduce production expr -> INT 
-- On AND reduce production expr -> INT 
-- On ADD reduce production expr -> INT 

State 71:
access -> IDENT . [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> IDENT . LPAR separated_nonempty_list(COMMA,expr) RPAR [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
-- On LPAR shift to state 72
-- On THEN reduce production access -> IDENT 
-- On SUB reduce production access -> IDENT 
-- On SEMICOLON reduce production access -> IDENT 
-- On RPAR reduce production access -> IDENT 
-- On REM reduce production access -> IDENT 
-- On OR reduce production access -> IDENT 
-- On NEQ reduce production access -> IDENT 
-- On MUL reduce production access -> IDENT 
-- On LT reduce production access -> IDENT 
-- On LOOP reduce production access -> IDENT 
-- On LE reduce production access -> IDENT 
-- On GT reduce production access -> IDENT 
-- On GE reduce production access -> IDENT 
-- On EQ reduce production access -> IDENT 
-- On DOUBLEDOT reduce production access -> IDENT 
-- On DOT reduce production access -> IDENT 
-- On DIV reduce production access -> IDENT 
-- On COMMA reduce production access -> IDENT 
-- On AND reduce production access -> IDENT 
-- On ADD reduce production access -> IDENT 

State 72:
expr -> IDENT LPAR . separated_nonempty_list(COMMA,expr) RPAR [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
-- On TRUE shift to state 63
-- On SUB shift to state 64
-- On NULL shift to state 65
-- On NOT shift to state 66
-- On NEW shift to state 67
-- On LPAR shift to state 69
-- On INT shift to state 70
-- On IDENT shift to state 71
-- On FALSE shift to state 73
-- On CHARVAL shift to state 74
-- On CHAR shift to state 76
-- On separated_nonempty_list(COMMA,expr) shift to state 112
-- On expr shift to state 114
-- On access shift to state 84

State 73:
expr -> FALSE . [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
-- On THEN reduce production expr -> FALSE 
-- On SUB reduce production expr -> FALSE 
-- On SEMICOLON reduce production expr -> FALSE 
-- On RPAR reduce production expr -> FALSE 
-- On REM reduce production expr -> FALSE 
-- On OR reduce production expr -> FALSE 
-- On NEQ reduce production expr -> FALSE 
-- On MUL reduce production expr -> FALSE 
-- On LT reduce production expr -> FALSE 
-- On LOOP reduce production expr -> FALSE 
-- On LE reduce production expr -> FALSE 
-- On GT reduce production expr -> FALSE 
-- On GE reduce production expr -> FALSE 
-- On EQ reduce production expr -> FALSE 
-- On DOUBLEDOT reduce production expr -> FALSE 
-- On DOT reduce production expr -> FALSE 
-- On DIV reduce production expr -> FALSE 
-- On COMMA reduce production expr -> FALSE 
-- On AND reduce production expr -> FALSE 
-- On ADD reduce production expr -> FALSE 

State 74:
expr -> CHARVAL . LPAR expr RPAR [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
-- On LPAR shift to state 75

State 75:
expr -> CHARVAL LPAR . expr RPAR [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
-- On TRUE shift to state 63
-- On SUB shift to state 64
-- On NULL shift to state 65
-- On NOT shift to state 66
-- On NEW shift to state 67
-- On LPAR shift to state 69
-- On INT shift to state 70
-- On IDENT shift to state 71
-- On FALSE shift to state 73
-- On CHARVAL shift to state 74
-- On CHAR shift to state 76
-- On expr shift to state 77
-- On access shift to state 84

State 76:
expr -> CHAR . [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
-- On THEN reduce production expr -> CHAR 
-- On SUB reduce production expr -> CHAR 
-- On SEMICOLON reduce production expr -> CHAR 
-- On RPAR reduce production expr -> CHAR 
-- On REM reduce production expr -> CHAR 
-- On OR reduce production expr -> CHAR 
-- On NEQ reduce production expr -> CHAR 
-- On MUL reduce production expr -> CHAR 
-- On LT reduce production expr -> CHAR 
-- On LOOP reduce production expr -> CHAR 
-- On LE reduce production expr -> CHAR 
-- On GT reduce production expr -> CHAR 
-- On GE reduce production expr -> CHAR 
-- On EQ reduce production expr -> CHAR 
-- On DOUBLEDOT reduce production expr -> CHAR 
-- On DOT reduce production expr -> CHAR 
-- On DIV reduce production expr -> CHAR 
-- On COMMA reduce production expr -> CHAR 
-- On AND reduce production expr -> CHAR 
-- On ADD reduce production expr -> CHAR 

State 77:
access -> expr . DOT IDENT [ SUB RPAR REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . AND THEN expr [ SUB RPAR REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . OR ELSE expr [ SUB RPAR REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . EQ expr [ SUB RPAR REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . NEQ expr [ SUB RPAR REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . LT expr [ SUB RPAR REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . LE expr [ SUB RPAR REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . GT expr [ SUB RPAR REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . GE expr [ SUB RPAR REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . ADD expr [ SUB RPAR REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . SUB expr [ SUB RPAR REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . MUL expr [ SUB RPAR REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . DIV expr [ SUB RPAR REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . REM expr [ SUB RPAR REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . AND expr [ SUB RPAR REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . OR expr [ SUB RPAR REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> CHARVAL LPAR expr . RPAR [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
-- On SUB shift to state 78
-- On RPAR shift to state 89
-- On REM shift to state 80
-- On OR shift to state 90
-- On NEQ shift to state 93
-- On MUL shift to state 85
-- On LT shift to state 95
-- On LE shift to state 99
-- On GT shift to state 101
-- On GE shift to state 103
-- On EQ shift to state 105
-- On DOT shift to state 82
-- On DIV shift to state 87
-- On AND shift to state 107
-- On ADD shift to state 97

State 78:
expr -> expr SUB . expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
-- On TRUE shift to state 63
-- On SUB shift to state 64
-- On NULL shift to state 65
-- On NOT shift to state 66
-- On NEW shift to state 67
-- On LPAR shift to state 69
-- On INT shift to state 70
-- On IDENT shift to state 71
-- On FALSE shift to state 73
-- On CHARVAL shift to state 74
-- On CHAR shift to state 76
-- On expr shift to state 79
-- On access shift to state 84

State 79:
access -> expr . DOT IDENT [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . AND THEN expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . OR ELSE expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . EQ expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . NEQ expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . LT expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . LE expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . GT expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . GE expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . ADD expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . SUB expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr SUB expr . [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . MUL expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . DIV expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . REM expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . AND expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . OR expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
-- On REM shift to state 80
-- On MUL shift to state 85
-- On DOT shift to state 82
-- On DIV shift to state 87
-- On THEN reduce production expr -> expr SUB expr 
-- On SUB reduce production expr -> expr SUB expr 
-- On SEMICOLON reduce production expr -> expr SUB expr 
-- On RPAR reduce production expr -> expr SUB expr 
-- On OR reduce production expr -> expr SUB expr 
-- On NEQ reduce production expr -> expr SUB expr 
-- On LT reduce production expr -> expr SUB expr 
-- On LOOP reduce production expr -> expr SUB expr 
-- On LE reduce production expr -> expr SUB expr 
-- On GT reduce production expr -> expr SUB expr 
-- On GE reduce production expr -> expr SUB expr 
-- On EQ reduce production expr -> expr SUB expr 
-- On DOUBLEDOT reduce production expr -> expr SUB expr 
-- On COMMA reduce production expr -> expr SUB expr 
-- On AND reduce production expr -> expr SUB expr 
-- On ADD reduce production expr -> expr SUB expr 

State 80:
expr -> expr REM . expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
-- On TRUE shift to state 63
-- On SUB shift to state 64
-- On NULL shift to state 65
-- On NOT shift to state 66
-- On NEW shift to state 67
-- On LPAR shift to state 69
-- On INT shift to state 70
-- On IDENT shift to state 71
-- On FALSE shift to state 73
-- On CHARVAL shift to state 74
-- On CHAR shift to state 76
-- On expr shift to state 81
-- On access shift to state 84

State 81:
access -> expr . DOT IDENT [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . AND THEN expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . OR ELSE expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . EQ expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . NEQ expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . LT expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . LE expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . GT expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . GE expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . ADD expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . SUB expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . MUL expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . DIV expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . REM expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr REM expr . [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . AND expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . OR expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
-- On DOT shift to state 82
-- On THEN reduce production expr -> expr REM expr 
-- On SUB reduce production expr -> expr REM expr 
-- On SEMICOLON reduce production expr -> expr REM expr 
-- On RPAR reduce production expr -> expr REM expr 
-- On REM reduce production expr -> expr REM expr 
-- On OR reduce production expr -> expr REM expr 
-- On NEQ reduce production expr -> expr REM expr 
-- On MUL reduce production expr -> expr REM expr 
-- On LT reduce production expr -> expr REM expr 
-- On LOOP reduce production expr -> expr REM expr 
-- On LE reduce production expr -> expr REM expr 
-- On GT reduce production expr -> expr REM expr 
-- On GE reduce production expr -> expr REM expr 
-- On EQ reduce production expr -> expr REM expr 
-- On DOUBLEDOT reduce production expr -> expr REM expr 
-- On DIV reduce production expr -> expr REM expr 
-- On COMMA reduce production expr -> expr REM expr 
-- On AND reduce production expr -> expr REM expr 
-- On ADD reduce production expr -> expr REM expr 

State 82:
access -> expr DOT . IDENT [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA COLONEQ AND ADD ]
-- On IDENT shift to state 83

State 83:
access -> expr DOT IDENT . [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA COLONEQ AND ADD ]
-- On THEN reduce production access -> expr DOT IDENT 
-- On SUB reduce production access -> expr DOT IDENT 
-- On SEMICOLON reduce production access -> expr DOT IDENT 
-- On RPAR reduce production access -> expr DOT IDENT 
-- On REM reduce production access -> expr DOT IDENT 
-- On OR reduce production access -> expr DOT IDENT 
-- On NEQ reduce production access -> expr DOT IDENT 
-- On MUL reduce production access -> expr DOT IDENT 
-- On LT reduce production access -> expr DOT IDENT 
-- On LOOP reduce production access -> expr DOT IDENT 
-- On LE reduce production access -> expr DOT IDENT 
-- On GT reduce production access -> expr DOT IDENT 
-- On GE reduce production access -> expr DOT IDENT 
-- On EQ reduce production access -> expr DOT IDENT 
-- On DOUBLEDOT reduce production access -> expr DOT IDENT 
-- On DOT reduce production access -> expr DOT IDENT 
-- On DIV reduce production access -> expr DOT IDENT 
-- On COMMA reduce production access -> expr DOT IDENT 
-- On COLONEQ reduce production access -> expr DOT IDENT 
-- On AND reduce production access -> expr DOT IDENT 
-- On ADD reduce production access -> expr DOT IDENT 

State 84:
expr -> access . [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
-- On THEN reduce production expr -> access 
-- On SUB reduce production expr -> access 
-- On SEMICOLON reduce production expr -> access 
-- On RPAR reduce production expr -> access 
-- On REM reduce production expr -> access 
-- On OR reduce production expr -> access 
-- On NEQ reduce production expr -> access 
-- On MUL reduce production expr -> access 
-- On LT reduce production expr -> access 
-- On LOOP reduce production expr -> access 
-- On LE reduce production expr -> access 
-- On GT reduce production expr -> access 
-- On GE reduce production expr -> access 
-- On EQ reduce production expr -> access 
-- On DOUBLEDOT reduce production expr -> access 
-- On DOT reduce production expr -> access 
-- On DIV reduce production expr -> access 
-- On COMMA reduce production expr -> access 
-- On AND reduce production expr -> access 
-- On ADD reduce production expr -> access 

State 85:
expr -> expr MUL . expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
-- On TRUE shift to state 63
-- On SUB shift to state 64
-- On NULL shift to state 65
-- On NOT shift to state 66
-- On NEW shift to state 67
-- On LPAR shift to state 69
-- On INT shift to state 70
-- On IDENT shift to state 71
-- On FALSE shift to state 73
-- On CHARVAL shift to state 74
-- On CHAR shift to state 76
-- On expr shift to state 86
-- On access shift to state 84

State 86:
access -> expr . DOT IDENT [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . AND THEN expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . OR ELSE expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . EQ expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . NEQ expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . LT expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . LE expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . GT expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . GE expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . ADD expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . SUB expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . MUL expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr MUL expr . [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . DIV expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . REM expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . AND expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . OR expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
-- On DOT shift to state 82
-- On THEN reduce production expr -> expr MUL expr 
-- On SUB reduce production expr -> expr MUL expr 
-- On SEMICOLON reduce production expr -> expr MUL expr 
-- On RPAR reduce production expr -> expr MUL expr 
-- On REM reduce production expr -> expr MUL expr 
-- On OR reduce production expr -> expr MUL expr 
-- On NEQ reduce production expr -> expr MUL expr 
-- On MUL reduce production expr -> expr MUL expr 
-- On LT reduce production expr -> expr MUL expr 
-- On LOOP reduce production expr -> expr MUL expr 
-- On LE reduce production expr -> expr MUL expr 
-- On GT reduce production expr -> expr MUL expr 
-- On GE reduce production expr -> expr MUL expr 
-- On EQ reduce production expr -> expr MUL expr 
-- On DOUBLEDOT reduce production expr -> expr MUL expr 
-- On DIV reduce production expr -> expr MUL expr 
-- On COMMA reduce production expr -> expr MUL expr 
-- On AND reduce production expr -> expr MUL expr 
-- On ADD reduce production expr -> expr MUL expr 

State 87:
expr -> expr DIV . expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
-- On TRUE shift to state 63
-- On SUB shift to state 64
-- On NULL shift to state 65
-- On NOT shift to state 66
-- On NEW shift to state 67
-- On LPAR shift to state 69
-- On INT shift to state 70
-- On IDENT shift to state 71
-- On FALSE shift to state 73
-- On CHARVAL shift to state 74
-- On CHAR shift to state 76
-- On expr shift to state 88
-- On access shift to state 84

State 88:
access -> expr . DOT IDENT [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . AND THEN expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . OR ELSE expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . EQ expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . NEQ expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . LT expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . LE expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . GT expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . GE expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . ADD expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . SUB expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . MUL expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . DIV expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr DIV expr . [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . REM expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . AND expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . OR expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
-- On DOT shift to state 82
-- On THEN reduce production expr -> expr DIV expr 
-- On SUB reduce production expr -> expr DIV expr 
-- On SEMICOLON reduce production expr -> expr DIV expr 
-- On RPAR reduce production expr -> expr DIV expr 
-- On REM reduce production expr -> expr DIV expr 
-- On OR reduce production expr -> expr DIV expr 
-- On NEQ reduce production expr -> expr DIV expr 
-- On MUL reduce production expr -> expr DIV expr 
-- On LT reduce production expr -> expr DIV expr 
-- On LOOP reduce production expr -> expr DIV expr 
-- On LE reduce production expr -> expr DIV expr 
-- On GT reduce production expr -> expr DIV expr 
-- On GE reduce production expr -> expr DIV expr 
-- On EQ reduce production expr -> expr DIV expr 
-- On DOUBLEDOT reduce production expr -> expr DIV expr 
-- On DIV reduce production expr -> expr DIV expr 
-- On COMMA reduce production expr -> expr DIV expr 
-- On AND reduce production expr -> expr DIV expr 
-- On ADD reduce production expr -> expr DIV expr 

State 89:
expr -> CHARVAL LPAR expr RPAR . [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
-- On THEN reduce production expr -> CHARVAL LPAR expr RPAR 
-- On SUB reduce production expr -> CHARVAL LPAR expr RPAR 
-- On SEMICOLON reduce production expr -> CHARVAL LPAR expr RPAR 
-- On RPAR reduce production expr -> CHARVAL LPAR expr RPAR 
-- On REM reduce production expr -> CHARVAL LPAR expr RPAR 
-- On OR reduce production expr -> CHARVAL LPAR expr RPAR 
-- On NEQ reduce production expr -> CHARVAL LPAR expr RPAR 
-- On MUL reduce production expr -> CHARVAL LPAR expr RPAR 
-- On LT reduce production expr -> CHARVAL LPAR expr RPAR 
-- On LOOP reduce production expr -> CHARVAL LPAR expr RPAR 
-- On LE reduce production expr -> CHARVAL LPAR expr RPAR 
-- On GT reduce production expr -> CHARVAL LPAR expr RPAR 
-- On GE reduce production expr -> CHARVAL LPAR expr RPAR 
-- On EQ reduce production expr -> CHARVAL LPAR expr RPAR 
-- On DOUBLEDOT reduce production expr -> CHARVAL LPAR expr RPAR 
-- On DOT reduce production expr -> CHARVAL LPAR expr RPAR 
-- On DIV reduce production expr -> CHARVAL LPAR expr RPAR 
-- On COMMA reduce production expr -> CHARVAL LPAR expr RPAR 
-- On AND reduce production expr -> CHARVAL LPAR expr RPAR 
-- On ADD reduce production expr -> CHARVAL LPAR expr RPAR 

State 90:
expr -> expr OR . ELSE expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr OR . expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
-- On TRUE shift to state 63
-- On SUB shift to state 64
-- On NULL shift to state 65
-- On NOT shift to state 66
-- On NEW shift to state 67
-- On LPAR shift to state 69
-- On INT shift to state 70
-- On IDENT shift to state 71
-- On FALSE shift to state 73
-- On ELSE shift to state 91
-- On CHARVAL shift to state 74
-- On CHAR shift to state 76
-- On expr shift to state 111
-- On access shift to state 84

State 91:
expr -> expr OR ELSE . expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
-- On TRUE shift to state 63
-- On SUB shift to state 64
-- On NULL shift to state 65
-- On NOT shift to state 66
-- On NEW shift to state 67
-- On LPAR shift to state 69
-- On INT shift to state 70
-- On IDENT shift to state 71
-- On FALSE shift to state 73
-- On CHARVAL shift to state 74
-- On CHAR shift to state 76
-- On expr shift to state 92
-- On access shift to state 84

State 92:
access -> expr . DOT IDENT [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . AND THEN expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . OR ELSE expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr OR ELSE expr . [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . EQ expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . NEQ expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . LT expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . LE expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . GT expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . GE expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . ADD expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . SUB expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . MUL expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . DIV expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . REM expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . AND expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . OR expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
-- On SUB shift to state 78
-- On REM shift to state 80
-- On NEQ shift to state 93
-- On MUL shift to state 85
-- On LT shift to state 95
-- On LE shift to state 99
-- On GT shift to state 101
-- On GE shift to state 103
-- On EQ shift to state 105
-- On DOT shift to state 82
-- On DIV shift to state 87
-- On AND shift to state 107
-- On ADD shift to state 97
-- On THEN reduce production expr -> expr OR ELSE expr 
-- On SEMICOLON reduce production expr -> expr OR ELSE expr 
-- On RPAR reduce production expr -> expr OR ELSE expr 
-- On OR reduce production expr -> expr OR ELSE expr 
-- On LOOP reduce production expr -> expr OR ELSE expr 
-- On DOUBLEDOT reduce production expr -> expr OR ELSE expr 
-- On COMMA reduce production expr -> expr OR ELSE expr 

State 93:
expr -> expr NEQ . expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
-- On TRUE shift to state 63
-- On SUB shift to state 64
-- On NULL shift to state 65
-- On NOT shift to state 66
-- On NEW shift to state 67
-- On LPAR shift to state 69
-- On INT shift to state 70
-- On IDENT shift to state 71
-- On FALSE shift to state 73
-- On CHARVAL shift to state 74
-- On CHAR shift to state 76
-- On expr shift to state 94
-- On access shift to state 84

State 94:
access -> expr . DOT IDENT [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . AND THEN expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . OR ELSE expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . EQ expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . NEQ expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr NEQ expr . [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . LT expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . LE expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . GT expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . GE expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . ADD expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . SUB expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . MUL expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . DIV expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . REM expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . AND expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . OR expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
-- On SUB shift to state 78
-- On REM shift to state 80
-- On MUL shift to state 85
-- On LT shift to state 95
-- On LE shift to state 99
-- On GT shift to state 101
-- On GE shift to state 103
-- On DOT shift to state 82
-- On DIV shift to state 87
-- On ADD shift to state 97
-- On THEN reduce production expr -> expr NEQ expr 
-- On SEMICOLON reduce production expr -> expr NEQ expr 
-- On RPAR reduce production expr -> expr NEQ expr 
-- On OR reduce production expr -> expr NEQ expr 
-- On LOOP reduce production expr -> expr NEQ expr 
-- On DOUBLEDOT reduce production expr -> expr NEQ expr 
-- On COMMA reduce production expr -> expr NEQ expr 
-- On AND reduce production expr -> expr NEQ expr 

State 95:
expr -> expr LT . expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
-- On TRUE shift to state 63
-- On SUB shift to state 64
-- On NULL shift to state 65
-- On NOT shift to state 66
-- On NEW shift to state 67
-- On LPAR shift to state 69
-- On INT shift to state 70
-- On IDENT shift to state 71
-- On FALSE shift to state 73
-- On CHARVAL shift to state 74
-- On CHAR shift to state 76
-- On expr shift to state 96
-- On access shift to state 84

State 96:
access -> expr . DOT IDENT [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . AND THEN expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . OR ELSE expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . EQ expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . NEQ expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . LT expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr LT expr . [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . LE expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . GT expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . GE expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . ADD expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . SUB expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . MUL expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . DIV expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . REM expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . AND expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . OR expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
-- On SUB shift to state 78
-- On REM shift to state 80
-- On MUL shift to state 85
-- On DOT shift to state 82
-- On DIV shift to state 87
-- On ADD shift to state 97
-- On THEN reduce production expr -> expr LT expr 
-- On SEMICOLON reduce production expr -> expr LT expr 
-- On RPAR reduce production expr -> expr LT expr 
-- On OR reduce production expr -> expr LT expr 
-- On NEQ reduce production expr -> expr LT expr 
-- On LOOP reduce production expr -> expr LT expr 
-- On EQ reduce production expr -> expr LT expr 
-- On DOUBLEDOT reduce production expr -> expr LT expr 
-- On COMMA reduce production expr -> expr LT expr 
-- On AND reduce production expr -> expr LT expr 

State 97:
expr -> expr ADD . expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
-- On TRUE shift to state 63
-- On SUB shift to state 64
-- On NULL shift to state 65
-- On NOT shift to state 66
-- On NEW shift to state 67
-- On LPAR shift to state 69
-- On INT shift to state 70
-- On IDENT shift to state 71
-- On FALSE shift to state 73
-- On CHARVAL shift to state 74
-- On CHAR shift to state 76
-- On expr shift to state 98
-- On access shift to state 84

State 98:
access -> expr . DOT IDENT [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . AND THEN expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . OR ELSE expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . EQ expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . NEQ expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . LT expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . LE expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . GT expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . GE expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . ADD expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr ADD expr . [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . SUB expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . MUL expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . DIV expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . REM expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . AND expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . OR expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
-- On REM shift to state 80
-- On MUL shift to state 85
-- On DOT shift to state 82
-- On DIV shift to state 87
-- On THEN reduce production expr -> expr ADD expr 
-- On SUB reduce production expr -> expr ADD expr 
-- On SEMICOLON reduce production expr -> expr ADD expr 
-- On RPAR reduce production expr -> expr ADD expr 
-- On OR reduce production expr -> expr ADD expr 
-- On NEQ reduce production expr -> expr ADD expr 
-- On LT reduce production expr -> expr ADD expr 
-- On LOOP reduce production expr -> expr ADD expr 
-- On LE reduce production expr -> expr ADD expr 
-- On GT reduce production expr -> expr ADD expr 
-- On GE reduce production expr -> expr ADD expr 
-- On EQ reduce production expr -> expr ADD expr 
-- On DOUBLEDOT reduce production expr -> expr ADD expr 
-- On COMMA reduce production expr -> expr ADD expr 
-- On AND reduce production expr -> expr ADD expr 
-- On ADD reduce production expr -> expr ADD expr 

State 99:
expr -> expr LE . expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
-- On TRUE shift to state 63
-- On SUB shift to state 64
-- On NULL shift to state 65
-- On NOT shift to state 66
-- On NEW shift to state 67
-- On LPAR shift to state 69
-- On INT shift to state 70
-- On IDENT shift to state 71
-- On FALSE shift to state 73
-- On CHARVAL shift to state 74
-- On CHAR shift to state 76
-- On expr shift to state 100
-- On access shift to state 84

State 100:
access -> expr . DOT IDENT [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . AND THEN expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . OR ELSE expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . EQ expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . NEQ expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . LT expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . LE expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr LE expr . [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . GT expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . GE expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . ADD expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . SUB expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . MUL expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . DIV expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . REM expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . AND expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . OR expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
-- On SUB shift to state 78
-- On REM shift to state 80
-- On MUL shift to state 85
-- On DOT shift to state 82
-- On DIV shift to state 87
-- On ADD shift to state 97
-- On THEN reduce production expr -> expr LE expr 
-- On SEMICOLON reduce production expr -> expr LE expr 
-- On RPAR reduce production expr -> expr LE expr 
-- On OR reduce production expr -> expr LE expr 
-- On NEQ reduce production expr -> expr LE expr 
-- On LOOP reduce production expr -> expr LE expr 
-- On EQ reduce production expr -> expr LE expr 
-- On DOUBLEDOT reduce production expr -> expr LE expr 
-- On COMMA reduce production expr -> expr LE expr 
-- On AND reduce production expr -> expr LE expr 

State 101:
expr -> expr GT . expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
-- On TRUE shift to state 63
-- On SUB shift to state 64
-- On NULL shift to state 65
-- On NOT shift to state 66
-- On NEW shift to state 67
-- On LPAR shift to state 69
-- On INT shift to state 70
-- On IDENT shift to state 71
-- On FALSE shift to state 73
-- On CHARVAL shift to state 74
-- On CHAR shift to state 76
-- On expr shift to state 102
-- On access shift to state 84

State 102:
access -> expr . DOT IDENT [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . AND THEN expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . OR ELSE expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . EQ expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . NEQ expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . LT expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . LE expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . GT expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr GT expr . [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . GE expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . ADD expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . SUB expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . MUL expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . DIV expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . REM expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . AND expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . OR expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
-- On SUB shift to state 78
-- On REM shift to state 80
-- On MUL shift to state 85
-- On DOT shift to state 82
-- On DIV shift to state 87
-- On ADD shift to state 97
-- On THEN reduce production expr -> expr GT expr 
-- On SEMICOLON reduce production expr -> expr GT expr 
-- On RPAR reduce production expr -> expr GT expr 
-- On OR reduce production expr -> expr GT expr 
-- On NEQ reduce production expr -> expr GT expr 
-- On LOOP reduce production expr -> expr GT expr 
-- On EQ reduce production expr -> expr GT expr 
-- On DOUBLEDOT reduce production expr -> expr GT expr 
-- On COMMA reduce production expr -> expr GT expr 
-- On AND reduce production expr -> expr GT expr 

State 103:
expr -> expr GE . expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
-- On TRUE shift to state 63
-- On SUB shift to state 64
-- On NULL shift to state 65
-- On NOT shift to state 66
-- On NEW shift to state 67
-- On LPAR shift to state 69
-- On INT shift to state 70
-- On IDENT shift to state 71
-- On FALSE shift to state 73
-- On CHARVAL shift to state 74
-- On CHAR shift to state 76
-- On expr shift to state 104
-- On access shift to state 84

State 104:
access -> expr . DOT IDENT [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . AND THEN expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . OR ELSE expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . EQ expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . NEQ expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . LT expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . LE expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . GT expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . GE expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr GE expr . [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . ADD expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . SUB expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . MUL expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . DIV expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . REM expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . AND expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . OR expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
-- On SUB shift to state 78
-- On REM shift to state 80
-- On MUL shift to state 85
-- On DOT shift to state 82
-- On DIV shift to state 87
-- On ADD shift to state 97
-- On THEN reduce production expr -> expr GE expr 
-- On SEMICOLON reduce production expr -> expr GE expr 
-- On RPAR reduce production expr -> expr GE expr 
-- On OR reduce production expr -> expr GE expr 
-- On NEQ reduce production expr -> expr GE expr 
-- On LOOP reduce production expr -> expr GE expr 
-- On EQ reduce production expr -> expr GE expr 
-- On DOUBLEDOT reduce production expr -> expr GE expr 
-- On COMMA reduce production expr -> expr GE expr 
-- On AND reduce production expr -> expr GE expr 

State 105:
expr -> expr EQ . expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
-- On TRUE shift to state 63
-- On SUB shift to state 64
-- On NULL shift to state 65
-- On NOT shift to state 66
-- On NEW shift to state 67
-- On LPAR shift to state 69
-- On INT shift to state 70
-- On IDENT shift to state 71
-- On FALSE shift to state 73
-- On CHARVAL shift to state 74
-- On CHAR shift to state 76
-- On expr shift to state 106
-- On access shift to state 84

State 106:
access -> expr . DOT IDENT [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . AND THEN expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . OR ELSE expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . EQ expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr EQ expr . [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . NEQ expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . LT expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . LE expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . GT expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . GE expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . ADD expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . SUB expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . MUL expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . DIV expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . REM expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . AND expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . OR expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
-- On SUB shift to state 78
-- On REM shift to state 80
-- On MUL shift to state 85
-- On LT shift to state 95
-- On LE shift to state 99
-- On GT shift to state 101
-- On GE shift to state 103
-- On DOT shift to state 82
-- On DIV shift to state 87
-- On ADD shift to state 97
-- On THEN reduce production expr -> expr EQ expr 
-- On SEMICOLON reduce production expr -> expr EQ expr 
-- On RPAR reduce production expr -> expr EQ expr 
-- On OR reduce production expr -> expr EQ expr 
-- On LOOP reduce production expr -> expr EQ expr 
-- On DOUBLEDOT reduce production expr -> expr EQ expr 
-- On COMMA reduce production expr -> expr EQ expr 
-- On AND reduce production expr -> expr EQ expr 

State 107:
expr -> expr AND . THEN expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr AND . expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
-- On TRUE shift to state 63
-- On THEN shift to state 108
-- On SUB shift to state 64
-- On NULL shift to state 65
-- On NOT shift to state 66
-- On NEW shift to state 67
-- On LPAR shift to state 69
-- On INT shift to state 70
-- On IDENT shift to state 71
-- On FALSE shift to state 73
-- On CHARVAL shift to state 74
-- On CHAR shift to state 76
-- On expr shift to state 110
-- On access shift to state 84

State 108:
expr -> expr AND THEN . expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
-- On TRUE shift to state 63
-- On SUB shift to state 64
-- On NULL shift to state 65
-- On NOT shift to state 66
-- On NEW shift to state 67
-- On LPAR shift to state 69
-- On INT shift to state 70
-- On IDENT shift to state 71
-- On FALSE shift to state 73
-- On CHARVAL shift to state 74
-- On CHAR shift to state 76
-- On expr shift to state 109
-- On access shift to state 84

State 109:
access -> expr . DOT IDENT [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . AND THEN expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr AND THEN expr . [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . OR ELSE expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . EQ expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . NEQ expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . LT expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . LE expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . GT expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . GE expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . ADD expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . SUB expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . MUL expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . DIV expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . REM expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . AND expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . OR expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
-- On SUB shift to state 78
-- On REM shift to state 80
-- On NEQ shift to state 93
-- On MUL shift to state 85
-- On LT shift to state 95
-- On LE shift to state 99
-- On GT shift to state 101
-- On GE shift to state 103
-- On EQ shift to state 105
-- On DOT shift to state 82
-- On DIV shift to state 87
-- On ADD shift to state 97
-- On THEN reduce production expr -> expr AND THEN expr 
-- On SEMICOLON reduce production expr -> expr AND THEN expr 
-- On RPAR reduce production expr -> expr AND THEN expr 
-- On OR reduce production expr -> expr AND THEN expr 
-- On LOOP reduce production expr -> expr AND THEN expr 
-- On DOUBLEDOT reduce production expr -> expr AND THEN expr 
-- On COMMA reduce production expr -> expr AND THEN expr 
-- On AND reduce production expr -> expr AND THEN expr 

State 110:
access -> expr . DOT IDENT [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . AND THEN expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . OR ELSE expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . EQ expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . NEQ expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . LT expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . LE expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . GT expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . GE expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . ADD expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . SUB expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . MUL expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . DIV expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . REM expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . AND expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr AND expr . [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . OR expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
-- On SUB shift to state 78
-- On REM shift to state 80
-- On NEQ shift to state 93
-- On MUL shift to state 85
-- On LT shift to state 95
-- On LE shift to state 99
-- On GT shift to state 101
-- On GE shift to state 103
-- On EQ shift to state 105
-- On DOT shift to state 82
-- On DIV shift to state 87
-- On ADD shift to state 97
-- On THEN reduce production expr -> expr AND expr 
-- On SEMICOLON reduce production expr -> expr AND expr 
-- On RPAR reduce production expr -> expr AND expr 
-- On OR reduce production expr -> expr AND expr 
-- On LOOP reduce production expr -> expr AND expr 
-- On DOUBLEDOT reduce production expr -> expr AND expr 
-- On COMMA reduce production expr -> expr AND expr 
-- On AND reduce production expr -> expr AND expr 

State 111:
access -> expr . DOT IDENT [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . AND THEN expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . OR ELSE expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . EQ expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . NEQ expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . LT expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . LE expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . GT expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . GE expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . ADD expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . SUB expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . MUL expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . DIV expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . REM expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . AND expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . OR expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr OR expr . [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
-- On SUB shift to state 78
-- On REM shift to state 80
-- On NEQ shift to state 93
-- On MUL shift to state 85
-- On LT shift to state 95
-- On LE shift to state 99
-- On GT shift to state 101
-- On GE shift to state 103
-- On EQ shift to state 105
-- On DOT shift to state 82
-- On DIV shift to state 87
-- On AND shift to state 107
-- On ADD shift to state 97
-- On THEN reduce production expr -> expr OR expr 
-- On SEMICOLON reduce production expr -> expr OR expr 
-- On RPAR reduce production expr -> expr OR expr 
-- On OR reduce production expr -> expr OR expr 
-- On LOOP reduce production expr -> expr OR expr 
-- On DOUBLEDOT reduce production expr -> expr OR expr 
-- On COMMA reduce production expr -> expr OR expr 

State 112:
expr -> IDENT LPAR separated_nonempty_list(COMMA,expr) . RPAR [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
-- On RPAR shift to state 113

State 113:
expr -> IDENT LPAR separated_nonempty_list(COMMA,expr) RPAR . [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
-- On THEN reduce production expr -> IDENT LPAR separated_nonempty_list(COMMA,expr) RPAR 
-- On SUB reduce production expr -> IDENT LPAR separated_nonempty_list(COMMA,expr) RPAR 
-- On SEMICOLON reduce production expr -> IDENT LPAR separated_nonempty_list(COMMA,expr) RPAR 
-- On RPAR reduce production expr -> IDENT LPAR separated_nonempty_list(COMMA,expr) RPAR 
-- On REM reduce production expr -> IDENT LPAR separated_nonempty_list(COMMA,expr) RPAR 
-- On OR reduce production expr -> IDENT LPAR separated_nonempty_list(COMMA,expr) RPAR 
-- On NEQ reduce production expr -> IDENT LPAR separated_nonempty_list(COMMA,expr) RPAR 
-- On MUL reduce production expr -> IDENT LPAR separated_nonempty_list(COMMA,expr) RPAR 
-- On LT reduce production expr -> IDENT LPAR separated_nonempty_list(COMMA,expr) RPAR 
-- On LOOP reduce production expr -> IDENT LPAR separated_nonempty_list(COMMA,expr) RPAR 
-- On LE reduce production expr -> IDENT LPAR separated_nonempty_list(COMMA,expr) RPAR 
-- On GT reduce production expr -> IDENT LPAR separated_nonempty_list(COMMA,expr) RPAR 
-- On GE reduce production expr -> IDENT LPAR separated_nonempty_list(COMMA,expr) RPAR 
-- On EQ reduce production expr -> IDENT LPAR separated_nonempty_list(COMMA,expr) RPAR 
-- On DOUBLEDOT reduce production expr -> IDENT LPAR separated_nonempty_list(COMMA,expr) RPAR 
-- On DOT reduce production expr -> IDENT LPAR separated_nonempty_list(COMMA,expr) RPAR 
-- On DIV reduce production expr -> IDENT LPAR separated_nonempty_list(COMMA,expr) RPAR 
-- On COMMA reduce production expr -> IDENT LPAR separated_nonempty_list(COMMA,expr) RPAR 
-- On AND reduce production expr -> IDENT LPAR separated_nonempty_list(COMMA,expr) RPAR 
-- On ADD reduce production expr -> IDENT LPAR separated_nonempty_list(COMMA,expr) RPAR 

State 114:
access -> expr . DOT IDENT [ SUB RPAR REM OR NEQ MUL LT LE GT GE EQ DOT DIV COMMA AND ADD ]
expr -> expr . AND THEN expr [ SUB RPAR REM OR NEQ MUL LT LE GT GE EQ DOT DIV COMMA AND ADD ]
expr -> expr . OR ELSE expr [ SUB RPAR REM OR NEQ MUL LT LE GT GE EQ DOT DIV COMMA AND ADD ]
expr -> expr . EQ expr [ SUB RPAR REM OR NEQ MUL LT LE GT GE EQ DOT DIV COMMA AND ADD ]
expr -> expr . NEQ expr [ SUB RPAR REM OR NEQ MUL LT LE GT GE EQ DOT DIV COMMA AND ADD ]
expr -> expr . LT expr [ SUB RPAR REM OR NEQ MUL LT LE GT GE EQ DOT DIV COMMA AND ADD ]
expr -> expr . LE expr [ SUB RPAR REM OR NEQ MUL LT LE GT GE EQ DOT DIV COMMA AND ADD ]
expr -> expr . GT expr [ SUB RPAR REM OR NEQ MUL LT LE GT GE EQ DOT DIV COMMA AND ADD ]
expr -> expr . GE expr [ SUB RPAR REM OR NEQ MUL LT LE GT GE EQ DOT DIV COMMA AND ADD ]
expr -> expr . ADD expr [ SUB RPAR REM OR NEQ MUL LT LE GT GE EQ DOT DIV COMMA AND ADD ]
expr -> expr . SUB expr [ SUB RPAR REM OR NEQ MUL LT LE GT GE EQ DOT DIV COMMA AND ADD ]
expr -> expr . MUL expr [ SUB RPAR REM OR NEQ MUL LT LE GT GE EQ DOT DIV COMMA AND ADD ]
expr -> expr . DIV expr [ SUB RPAR REM OR NEQ MUL LT LE GT GE EQ DOT DIV COMMA AND ADD ]
expr -> expr . REM expr [ SUB RPAR REM OR NEQ MUL LT LE GT GE EQ DOT DIV COMMA AND ADD ]
expr -> expr . AND expr [ SUB RPAR REM OR NEQ MUL LT LE GT GE EQ DOT DIV COMMA AND ADD ]
expr -> expr . OR expr [ SUB RPAR REM OR NEQ MUL LT LE GT GE EQ DOT DIV COMMA AND ADD ]
separated_nonempty_list(COMMA,expr) -> expr . [ RPAR ]
separated_nonempty_list(COMMA,expr) -> expr . COMMA separated_nonempty_list(COMMA,expr) [ RPAR ]
-- On SUB shift to state 78
-- On REM shift to state 80
-- On OR shift to state 90
-- On NEQ shift to state 93
-- On MUL shift to state 85
-- On LT shift to state 95
-- On LE shift to state 99
-- On GT shift to state 101
-- On GE shift to state 103
-- On EQ shift to state 105
-- On DOT shift to state 82
-- On DIV shift to state 87
-- On COMMA shift to state 115
-- On AND shift to state 107
-- On ADD shift to state 97
-- On RPAR reduce production separated_nonempty_list(COMMA,expr) -> expr 

State 115:
separated_nonempty_list(COMMA,expr) -> expr COMMA . separated_nonempty_list(COMMA,expr) [ RPAR ]
-- On TRUE shift to state 63
-- On SUB shift to state 64
-- On NULL shift to state 65
-- On NOT shift to state 66
-- On NEW shift to state 67
-- On LPAR shift to state 69
-- On INT shift to state 70
-- On IDENT shift to state 71
-- On FALSE shift to state 73
-- On CHARVAL shift to state 74
-- On CHAR shift to state 76
-- On separated_nonempty_list(COMMA,expr) shift to state 116
-- On expr shift to state 114
-- On access shift to state 84

State 116:
separated_nonempty_list(COMMA,expr) -> expr COMMA separated_nonempty_list(COMMA,expr) . [ RPAR ]
-- On RPAR reduce production separated_nonempty_list(COMMA,expr) -> expr COMMA separated_nonempty_list(COMMA,expr) 

State 117:
access -> expr . DOT IDENT [ SUB RPAR REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> LPAR expr . RPAR [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . AND THEN expr [ SUB RPAR REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . OR ELSE expr [ SUB RPAR REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . EQ expr [ SUB RPAR REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . NEQ expr [ SUB RPAR REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . LT expr [ SUB RPAR REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . LE expr [ SUB RPAR REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . GT expr [ SUB RPAR REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . GE expr [ SUB RPAR REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . ADD expr [ SUB RPAR REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . SUB expr [ SUB RPAR REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . MUL expr [ SUB RPAR REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . DIV expr [ SUB RPAR REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . REM expr [ SUB RPAR REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . AND expr [ SUB RPAR REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . OR expr [ SUB RPAR REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
-- On SUB shift to state 78
-- On RPAR shift to state 118
-- On REM shift to state 80
-- On OR shift to state 90
-- On NEQ shift to state 93
-- On MUL shift to state 85
-- On LT shift to state 95
-- On LE shift to state 99
-- On GT shift to state 101
-- On GE shift to state 103
-- On EQ shift to state 105
-- On DOT shift to state 82
-- On DIV shift to state 87
-- On AND shift to state 107
-- On ADD shift to state 97

State 118:
expr -> LPAR expr RPAR . [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
-- On THEN reduce production expr -> LPAR expr RPAR 
-- On SUB reduce production expr -> LPAR expr RPAR 
-- On SEMICOLON reduce production expr -> LPAR expr RPAR 
-- On RPAR reduce production expr -> LPAR expr RPAR 
-- On REM reduce production expr -> LPAR expr RPAR 
-- On OR reduce production expr -> LPAR expr RPAR 
-- On NEQ reduce production expr -> LPAR expr RPAR 
-- On MUL reduce production expr -> LPAR expr RPAR 
-- On LT reduce production expr -> LPAR expr RPAR 
-- On LOOP reduce production expr -> LPAR expr RPAR 
-- On LE reduce production expr -> LPAR expr RPAR 
-- On GT reduce production expr -> LPAR expr RPAR 
-- On GE reduce production expr -> LPAR expr RPAR 
-- On EQ reduce production expr -> LPAR expr RPAR 
-- On DOUBLEDOT reduce production expr -> LPAR expr RPAR 
-- On DOT reduce production expr -> LPAR expr RPAR 
-- On DIV reduce production expr -> LPAR expr RPAR 
-- On COMMA reduce production expr -> LPAR expr RPAR 
-- On AND reduce production expr -> LPAR expr RPAR 
-- On ADD reduce production expr -> LPAR expr RPAR 

State 119:
access -> expr . DOT IDENT [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . AND THEN expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . OR ELSE expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . EQ expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . NEQ expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . LT expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . LE expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . GT expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . GE expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . ADD expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . SUB expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . MUL expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . DIV expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . REM expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . AND expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . OR expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> NOT expr . [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
-- On SUB shift to state 78
-- On REM shift to state 80
-- On NEQ shift to state 93
-- On MUL shift to state 85
-- On LT shift to state 95
-- On LE shift to state 99
-- On GT shift to state 101
-- On GE shift to state 103
-- On EQ shift to state 105
-- On DOT shift to state 82
-- On DIV shift to state 87
-- On ADD shift to state 97
-- On THEN reduce production expr -> NOT expr 
-- On SEMICOLON reduce production expr -> NOT expr 
-- On RPAR reduce production expr -> NOT expr 
-- On OR reduce production expr -> NOT expr 
-- On LOOP reduce production expr -> NOT expr 
-- On DOUBLEDOT reduce production expr -> NOT expr 
-- On COMMA reduce production expr -> NOT expr 
-- On AND reduce production expr -> NOT expr 

State 120:
access -> expr . DOT IDENT [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . AND THEN expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . OR ELSE expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . EQ expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . NEQ expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . LT expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . LE expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . GT expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . GE expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . ADD expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . SUB expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . MUL expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . DIV expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . REM expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . AND expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> expr . OR expr [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
expr -> SUB expr . [ THEN SUB SEMICOLON RPAR REM OR NEQ MUL LT LOOP LE GT GE EQ DOUBLEDOT DOT DIV COMMA AND ADD ]
-- On DOT shift to state 82
-- On THEN reduce production expr -> SUB expr 
-- On SUB reduce production expr -> SUB expr 
-- On SEMICOLON reduce production expr -> SUB expr 
-- On RPAR reduce production expr -> SUB expr 
-- On REM reduce production expr -> SUB expr 
-- On OR reduce production expr -> SUB expr 
-- On NEQ reduce production expr -> SUB expr 
-- On MUL reduce production expr -> SUB expr 
-- On LT reduce production expr -> SUB expr 
-- On LOOP reduce production expr -> SUB expr 
-- On LE reduce production expr -> SUB expr 
-- On GT reduce production expr -> SUB expr 
-- On GE reduce production expr -> SUB expr 
-- On EQ reduce production expr -> SUB expr 
-- On DOUBLEDOT reduce production expr -> SUB expr 
-- On DIV reduce production expr -> SUB expr 
-- On COMMA reduce production expr -> SUB expr 
-- On AND reduce production expr -> SUB expr 
-- On ADD reduce production expr -> SUB expr 

State 121:
access -> expr . DOT IDENT [ SUB SEMICOLON REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
decl -> separated_nonempty_list(COMMA,IDENT) COLON stype COLONEQ expr . SEMICOLON [ TYPE PROCEDURE IDENT FUNCTION BEGIN ]
expr -> expr . AND THEN expr [ SUB SEMICOLON REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . OR ELSE expr [ SUB SEMICOLON REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . EQ expr [ SUB SEMICOLON REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . NEQ expr [ SUB SEMICOLON REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . LT expr [ SUB SEMICOLON REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . LE expr [ SUB SEMICOLON REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . GT expr [ SUB SEMICOLON REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . GE expr [ SUB SEMICOLON REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . ADD expr [ SUB SEMICOLON REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . SUB expr [ SUB SEMICOLON REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . MUL expr [ SUB SEMICOLON REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . DIV expr [ SUB SEMICOLON REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . REM expr [ SUB SEMICOLON REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . AND expr [ SUB SEMICOLON REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . OR expr [ SUB SEMICOLON REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
-- On SUB shift to state 78
-- On SEMICOLON shift to state 122
-- On REM shift to state 80
-- On OR shift to state 90
-- On NEQ shift to state 93
-- On MUL shift to state 85
-- On LT shift to state 95
-- On LE shift to state 99
-- On GT shift to state 101
-- On GE shift to state 103
-- On EQ shift to state 105
-- On DOT shift to state 82
-- On DIV shift to state 87
-- On AND shift to state 107
-- On ADD shift to state 97

State 122:
decl -> separated_nonempty_list(COMMA,IDENT) COLON stype COLONEQ expr SEMICOLON . [ TYPE PROCEDURE IDENT FUNCTION BEGIN ]
-- On TYPE reduce production decl -> separated_nonempty_list(COMMA,IDENT) COLON stype COLONEQ expr SEMICOLON 
-- On PROCEDURE reduce production decl -> separated_nonempty_list(COMMA,IDENT) COLON stype COLONEQ expr SEMICOLON 
-- On IDENT reduce production decl -> separated_nonempty_list(COMMA,IDENT) COLON stype COLONEQ expr SEMICOLON 
-- On FUNCTION reduce production decl -> separated_nonempty_list(COMMA,IDENT) COLON stype COLONEQ expr SEMICOLON 
-- On BEGIN reduce production decl -> separated_nonempty_list(COMMA,IDENT) COLON stype COLONEQ expr SEMICOLON 

State 123:
decl -> FUNCTION IDENT option(params) RETURN stype IS list(decl) . BEGIN nonempty_list(stmt) END option(IDENT) SEMICOLON [ TYPE PROCEDURE IDENT FUNCTION BEGIN ]
-- On BEGIN shift to state 124

State 124:
decl -> FUNCTION IDENT option(params) RETURN stype IS list(decl) BEGIN . nonempty_list(stmt) END option(IDENT) SEMICOLON [ TYPE PROCEDURE IDENT FUNCTION BEGIN ]
-- On WHILE shift to state 125
-- On TRUE shift to state 63
-- On SUB shift to state 64
-- On RETURN shift to state 128
-- On NULL shift to state 65
-- On NOT shift to state 66
-- On NEW shift to state 67
-- On LPAR shift to state 69
-- On INT shift to state 70
-- On IF shift to state 132
-- On IDENT shift to state 135
-- On FOR shift to state 141
-- On FALSE shift to state 73
-- On CHARVAL shift to state 74
-- On CHAR shift to state 76
-- On BEGIN shift to state 150
-- On stmt shift to state 151
-- On nonempty_list(stmt) shift to state 184
-- On expr shift to state 153
-- On access shift to state 154

State 125:
stmt -> WHILE . expr LOOP nonempty_list(stmt) END LOOP SEMICOLON [ WHILE TRUE SUB RETURN NULL NOT NEW LPAR INT IF IDENT FOR FALSE END ELSIF ELSE CHARVAL CHAR BEGIN ]
-- On TRUE shift to state 63
-- On SUB shift to state 64
-- On NULL shift to state 65
-- On NOT shift to state 66
-- On NEW shift to state 67
-- On LPAR shift to state 69
-- On INT shift to state 70
-- On IDENT shift to state 71
-- On FALSE shift to state 73
-- On CHARVAL shift to state 74
-- On CHAR shift to state 76
-- On expr shift to state 126
-- On access shift to state 84

State 126:
access -> expr . DOT IDENT [ SUB REM OR NEQ MUL LT LOOP LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . AND THEN expr [ SUB REM OR NEQ MUL LT LOOP LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . OR ELSE expr [ SUB REM OR NEQ MUL LT LOOP LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . EQ expr [ SUB REM OR NEQ MUL LT LOOP LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . NEQ expr [ SUB REM OR NEQ MUL LT LOOP LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . LT expr [ SUB REM OR NEQ MUL LT LOOP LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . LE expr [ SUB REM OR NEQ MUL LT LOOP LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . GT expr [ SUB REM OR NEQ MUL LT LOOP LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . GE expr [ SUB REM OR NEQ MUL LT LOOP LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . ADD expr [ SUB REM OR NEQ MUL LT LOOP LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . SUB expr [ SUB REM OR NEQ MUL LT LOOP LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . MUL expr [ SUB REM OR NEQ MUL LT LOOP LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . DIV expr [ SUB REM OR NEQ MUL LT LOOP LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . REM expr [ SUB REM OR NEQ MUL LT LOOP LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . AND expr [ SUB REM OR NEQ MUL LT LOOP LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . OR expr [ SUB REM OR NEQ MUL LT LOOP LE GT GE EQ DOT DIV AND ADD ]
stmt -> WHILE expr . LOOP nonempty_list(stmt) END LOOP SEMICOLON [ WHILE TRUE SUB RETURN NULL NOT NEW LPAR INT IF IDENT FOR FALSE END ELSIF ELSE CHARVAL CHAR BEGIN ]
-- On SUB shift to state 78
-- On REM shift to state 80
-- On OR shift to state 90
-- On NEQ shift to state 93
-- On MUL shift to state 85
-- On LT shift to state 95
-- On LOOP shift to state 127
-- On LE shift to state 99
-- On GT shift to state 101
-- On GE shift to state 103
-- On EQ shift to state 105
-- On DOT shift to state 82
-- On DIV shift to state 87
-- On AND shift to state 107
-- On ADD shift to state 97

State 127:
stmt -> WHILE expr LOOP . nonempty_list(stmt) END LOOP SEMICOLON [ WHILE TRUE SUB RETURN NULL NOT NEW LPAR INT IF IDENT FOR FALSE END ELSIF ELSE CHARVAL CHAR BEGIN ]
-- On WHILE shift to state 125
-- On TRUE shift to state 63
-- On SUB shift to state 64
-- On RETURN shift to state 128
-- On NULL shift to state 65
-- On NOT shift to state 66
-- On NEW shift to state 67
-- On LPAR shift to state 69
-- On INT shift to state 70
-- On IF shift to state 132
-- On IDENT shift to state 135
-- On FOR shift to state 141
-- On FALSE shift to state 73
-- On CHARVAL shift to state 74
-- On CHAR shift to state 76
-- On BEGIN shift to state 150
-- On stmt shift to state 151
-- On nonempty_list(stmt) shift to state 180
-- On expr shift to state 153
-- On access shift to state 154

State 128:
stmt -> RETURN . option(expr) SEMICOLON [ WHILE TRUE SUB RETURN NULL NOT NEW LPAR INT IF IDENT FOR FALSE END ELSIF ELSE CHARVAL CHAR BEGIN ]
-- On TRUE shift to state 63
-- On SUB shift to state 64
-- On NULL shift to state 65
-- On NOT shift to state 66
-- On NEW shift to state 67
-- On LPAR shift to state 69
-- On INT shift to state 70
-- On IDENT shift to state 71
-- On FALSE shift to state 73
-- On CHARVAL shift to state 74
-- On CHAR shift to state 76
-- On option(expr) shift to state 129
-- On expr shift to state 131
-- On access shift to state 84
-- On SEMICOLON reduce production option(expr) -> 

State 129:
stmt -> RETURN option(expr) . SEMICOLON [ WHILE TRUE SUB RETURN NULL NOT NEW LPAR INT IF IDENT FOR FALSE END ELSIF ELSE CHARVAL CHAR BEGIN ]
-- On SEMICOLON shift to state 130

State 130:
stmt -> RETURN option(expr) SEMICOLON . [ WHILE TRUE SUB RETURN NULL NOT NEW LPAR INT IF IDENT FOR FALSE END ELSIF ELSE CHARVAL CHAR BEGIN ]
-- On WHILE reduce production stmt -> RETURN option(expr) SEMICOLON 
-- On TRUE reduce production stmt -> RETURN option(expr) SEMICOLON 
-- On SUB reduce production stmt -> RETURN option(expr) SEMICOLON 
-- On RETURN reduce production stmt -> RETURN option(expr) SEMICOLON 
-- On NULL reduce production stmt -> RETURN option(expr) SEMICOLON 
-- On NOT reduce production stmt -> RETURN option(expr) SEMICOLON 
-- On NEW reduce production stmt -> RETURN option(expr) SEMICOLON 
-- On LPAR reduce production stmt -> RETURN option(expr) SEMICOLON 
-- On INT reduce production stmt -> RETURN option(expr) SEMICOLON 
-- On IF reduce production stmt -> RETURN option(expr) SEMICOLON 
-- On IDENT reduce production stmt -> RETURN option(expr) SEMICOLON 
-- On FOR reduce production stmt -> RETURN option(expr) SEMICOLON 
-- On FALSE reduce production stmt -> RETURN option(expr) SEMICOLON 
-- On END reduce production stmt -> RETURN option(expr) SEMICOLON 
-- On ELSIF reduce production stmt -> RETURN option(expr) SEMICOLON 
-- On ELSE reduce production stmt -> RETURN option(expr) SEMICOLON 
-- On CHARVAL reduce production stmt -> RETURN option(expr) SEMICOLON 
-- On CHAR reduce production stmt -> RETURN option(expr) SEMICOLON 
-- On BEGIN reduce production stmt -> RETURN option(expr) SEMICOLON 

State 131:
access -> expr . DOT IDENT [ SUB SEMICOLON REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . AND THEN expr [ SUB SEMICOLON REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . OR ELSE expr [ SUB SEMICOLON REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . EQ expr [ SUB SEMICOLON REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . NEQ expr [ SUB SEMICOLON REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . LT expr [ SUB SEMICOLON REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . LE expr [ SUB SEMICOLON REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . GT expr [ SUB SEMICOLON REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . GE expr [ SUB SEMICOLON REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . ADD expr [ SUB SEMICOLON REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . SUB expr [ SUB SEMICOLON REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . MUL expr [ SUB SEMICOLON REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . DIV expr [ SUB SEMICOLON REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . REM expr [ SUB SEMICOLON REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . AND expr [ SUB SEMICOLON REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . OR expr [ SUB SEMICOLON REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
option(expr) -> expr . [ SEMICOLON ]
-- On SUB shift to state 78
-- On REM shift to state 80
-- On OR shift to state 90
-- On NEQ shift to state 93
-- On MUL shift to state 85
-- On LT shift to state 95
-- On LE shift to state 99
-- On GT shift to state 101
-- On GE shift to state 103
-- On EQ shift to state 105
-- On DOT shift to state 82
-- On DIV shift to state 87
-- On AND shift to state 107
-- On ADD shift to state 97
-- On SEMICOLON reduce production option(expr) -> expr 

State 132:
stmt -> IF . expr THEN nonempty_list(stmt) condition [ WHILE TRUE SUB RETURN NULL NOT NEW LPAR INT IF IDENT FOR FALSE END ELSIF ELSE CHARVAL CHAR BEGIN ]
-- On TRUE shift to state 63
-- On SUB shift to state 64
-- On NULL shift to state 65
-- On NOT shift to state 66
-- On NEW shift to state 67
-- On LPAR shift to state 69
-- On INT shift to state 70
-- On IDENT shift to state 71
-- On FALSE shift to state 73
-- On CHARVAL shift to state 74
-- On CHAR shift to state 76
-- On expr shift to state 133
-- On access shift to state 84

State 133:
access -> expr . DOT IDENT [ THEN SUB REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . AND THEN expr [ THEN SUB REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . OR ELSE expr [ THEN SUB REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . EQ expr [ THEN SUB REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . NEQ expr [ THEN SUB REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . LT expr [ THEN SUB REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . LE expr [ THEN SUB REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . GT expr [ THEN SUB REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . GE expr [ THEN SUB REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . ADD expr [ THEN SUB REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . SUB expr [ THEN SUB REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . MUL expr [ THEN SUB REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . DIV expr [ THEN SUB REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . REM expr [ THEN SUB REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . AND expr [ THEN SUB REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . OR expr [ THEN SUB REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
stmt -> IF expr . THEN nonempty_list(stmt) condition [ WHILE TRUE SUB RETURN NULL NOT NEW LPAR INT IF IDENT FOR FALSE END ELSIF ELSE CHARVAL CHAR BEGIN ]
-- On THEN shift to state 134
-- On SUB shift to state 78
-- On REM shift to state 80
-- On OR shift to state 90
-- On NEQ shift to state 93
-- On MUL shift to state 85
-- On LT shift to state 95
-- On LE shift to state 99
-- On GT shift to state 101
-- On GE shift to state 103
-- On EQ shift to state 105
-- On DOT shift to state 82
-- On DIV shift to state 87
-- On AND shift to state 107
-- On ADD shift to state 97

State 134:
stmt -> IF expr THEN . nonempty_list(stmt) condition [ WHILE TRUE SUB RETURN NULL NOT NEW LPAR INT IF IDENT FOR FALSE END ELSIF ELSE CHARVAL CHAR BEGIN ]
-- On WHILE shift to state 125
-- On TRUE shift to state 63
-- On SUB shift to state 64
-- On RETURN shift to state 128
-- On NULL shift to state 65
-- On NOT shift to state 66
-- On NEW shift to state 67
-- On LPAR shift to state 69
-- On INT shift to state 70
-- On IF shift to state 132
-- On IDENT shift to state 135
-- On FOR shift to state 141
-- On FALSE shift to state 73
-- On CHARVAL shift to state 74
-- On CHAR shift to state 76
-- On BEGIN shift to state 150
-- On stmt shift to state 151
-- On nonempty_list(stmt) shift to state 165
-- On expr shift to state 153
-- On access shift to state 154

State 135:
access -> IDENT . [ SUB REM OR NEQ MUL LT LE GT GE EQ DOT DIV COLONEQ AND ADD ]
expr -> IDENT . LPAR separated_nonempty_list(COMMA,expr) RPAR [ SUB REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
stmt -> IDENT . SEMICOLON [ WHILE TRUE SUB RETURN NULL NOT NEW LPAR INT IF IDENT FOR FALSE END ELSIF ELSE CHARVAL CHAR BEGIN ]
stmt -> IDENT . LPAR separated_nonempty_list(COMMA,expr) RPAR SEMICOLON [ WHILE TRUE SUB RETURN NULL NOT NEW LPAR INT IF IDENT FOR FALSE END ELSIF ELSE CHARVAL CHAR BEGIN ]
-- On SEMICOLON shift to state 136
-- On LPAR shift to state 137
-- On SUB reduce production access -> IDENT 
-- On REM reduce production access -> IDENT 
-- On OR reduce production access -> IDENT 
-- On NEQ reduce production access -> IDENT 
-- On MUL reduce production access -> IDENT 
-- On LT reduce production access -> IDENT 
-- On LE reduce production access -> IDENT 
-- On GT reduce production access -> IDENT 
-- On GE reduce production access -> IDENT 
-- On EQ reduce production access -> IDENT 
-- On DOT reduce production access -> IDENT 
-- On DIV reduce production access -> IDENT 
-- On COLONEQ reduce production access -> IDENT 
-- On AND reduce production access -> IDENT 
-- On ADD reduce production access -> IDENT 

State 136:
stmt -> IDENT SEMICOLON . [ WHILE TRUE SUB RETURN NULL NOT NEW LPAR INT IF IDENT FOR FALSE END ELSIF ELSE CHARVAL CHAR BEGIN ]
-- On WHILE reduce production stmt -> IDENT SEMICOLON 
-- On TRUE reduce production stmt -> IDENT SEMICOLON 
-- On SUB reduce production stmt -> IDENT SEMICOLON 
-- On RETURN reduce production stmt -> IDENT SEMICOLON 
-- On NULL reduce production stmt -> IDENT SEMICOLON 
-- On NOT reduce production stmt -> IDENT SEMICOLON 
-- On NEW reduce production stmt -> IDENT SEMICOLON 
-- On LPAR reduce production stmt -> IDENT SEMICOLON 
-- On INT reduce production stmt -> IDENT SEMICOLON 
-- On IF reduce production stmt -> IDENT SEMICOLON 
-- On IDENT reduce production stmt -> IDENT SEMICOLON 
-- On FOR reduce production stmt -> IDENT SEMICOLON 
-- On FALSE reduce production stmt -> IDENT SEMICOLON 
-- On END reduce production stmt -> IDENT SEMICOLON 
-- On ELSIF reduce production stmt -> IDENT SEMICOLON 
-- On ELSE reduce production stmt -> IDENT SEMICOLON 
-- On CHARVAL reduce production stmt -> IDENT SEMICOLON 
-- On CHAR reduce production stmt -> IDENT SEMICOLON 
-- On BEGIN reduce production stmt -> IDENT SEMICOLON 

State 137:
expr -> IDENT LPAR . separated_nonempty_list(COMMA,expr) RPAR [ SUB REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
stmt -> IDENT LPAR . separated_nonempty_list(COMMA,expr) RPAR SEMICOLON [ WHILE TRUE SUB RETURN NULL NOT NEW LPAR INT IF IDENT FOR FALSE END ELSIF ELSE CHARVAL CHAR BEGIN ]
-- On TRUE shift to state 63
-- On SUB shift to state 64
-- On NULL shift to state 65
-- On NOT shift to state 66
-- On NEW shift to state 67
-- On LPAR shift to state 69
-- On INT shift to state 70
-- On IDENT shift to state 71
-- On FALSE shift to state 73
-- On CHARVAL shift to state 74
-- On CHAR shift to state 76
-- On separated_nonempty_list(COMMA,expr) shift to state 138
-- On expr shift to state 114
-- On access shift to state 84

State 138:
expr -> IDENT LPAR separated_nonempty_list(COMMA,expr) . RPAR [ SUB REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
stmt -> IDENT LPAR separated_nonempty_list(COMMA,expr) . RPAR SEMICOLON [ WHILE TRUE SUB RETURN NULL NOT NEW LPAR INT IF IDENT FOR FALSE END ELSIF ELSE CHARVAL CHAR BEGIN ]
-- On RPAR shift to state 139

State 139:
expr -> IDENT LPAR separated_nonempty_list(COMMA,expr) RPAR . [ SUB REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
stmt -> IDENT LPAR separated_nonempty_list(COMMA,expr) RPAR . SEMICOLON [ WHILE TRUE SUB RETURN NULL NOT NEW LPAR INT IF IDENT FOR FALSE END ELSIF ELSE CHARVAL CHAR BEGIN ]
-- On SEMICOLON shift to state 140
-- On SUB reduce production expr -> IDENT LPAR separated_nonempty_list(COMMA,expr) RPAR 
-- On REM reduce production expr -> IDENT LPAR separated_nonempty_list(COMMA,expr) RPAR 
-- On OR reduce production expr -> IDENT LPAR separated_nonempty_list(COMMA,expr) RPAR 
-- On NEQ reduce production expr -> IDENT LPAR separated_nonempty_list(COMMA,expr) RPAR 
-- On MUL reduce production expr -> IDENT LPAR separated_nonempty_list(COMMA,expr) RPAR 
-- On LT reduce production expr -> IDENT LPAR separated_nonempty_list(COMMA,expr) RPAR 
-- On LE reduce production expr -> IDENT LPAR separated_nonempty_list(COMMA,expr) RPAR 
-- On GT reduce production expr -> IDENT LPAR separated_nonempty_list(COMMA,expr) RPAR 
-- On GE reduce production expr -> IDENT LPAR separated_nonempty_list(COMMA,expr) RPAR 
-- On EQ reduce production expr -> IDENT LPAR separated_nonempty_list(COMMA,expr) RPAR 
-- On DOT reduce production expr -> IDENT LPAR separated_nonempty_list(COMMA,expr) RPAR 
-- On DIV reduce production expr -> IDENT LPAR separated_nonempty_list(COMMA,expr) RPAR 
-- On AND reduce production expr -> IDENT LPAR separated_nonempty_list(COMMA,expr) RPAR 
-- On ADD reduce production expr -> IDENT LPAR separated_nonempty_list(COMMA,expr) RPAR 

State 140:
stmt -> IDENT LPAR separated_nonempty_list(COMMA,expr) RPAR SEMICOLON . [ WHILE TRUE SUB RETURN NULL NOT NEW LPAR INT IF IDENT FOR FALSE END ELSIF ELSE CHARVAL CHAR BEGIN ]
-- On WHILE reduce production stmt -> IDENT LPAR separated_nonempty_list(COMMA,expr) RPAR SEMICOLON 
-- On TRUE reduce production stmt -> IDENT LPAR separated_nonempty_list(COMMA,expr) RPAR SEMICOLON 
-- On SUB reduce production stmt -> IDENT LPAR separated_nonempty_list(COMMA,expr) RPAR SEMICOLON 
-- On RETURN reduce production stmt -> IDENT LPAR separated_nonempty_list(COMMA,expr) RPAR SEMICOLON 
-- On NULL reduce production stmt -> IDENT LPAR separated_nonempty_list(COMMA,expr) RPAR SEMICOLON 
-- On NOT reduce production stmt -> IDENT LPAR separated_nonempty_list(COMMA,expr) RPAR SEMICOLON 
-- On NEW reduce production stmt -> IDENT LPAR separated_nonempty_list(COMMA,expr) RPAR SEMICOLON 
-- On LPAR reduce production stmt -> IDENT LPAR separated_nonempty_list(COMMA,expr) RPAR SEMICOLON 
-- On INT reduce production stmt -> IDENT LPAR separated_nonempty_list(COMMA,expr) RPAR SEMICOLON 
-- On IF reduce production stmt -> IDENT LPAR separated_nonempty_list(COMMA,expr) RPAR SEMICOLON 
-- On IDENT reduce production stmt -> IDENT LPAR separated_nonempty_list(COMMA,expr) RPAR SEMICOLON 
-- On FOR reduce production stmt -> IDENT LPAR separated_nonempty_list(COMMA,expr) RPAR SEMICOLON 
-- On FALSE reduce production stmt -> IDENT LPAR separated_nonempty_list(COMMA,expr) RPAR SEMICOLON 
-- On END reduce production stmt -> IDENT LPAR separated_nonempty_list(COMMA,expr) RPAR SEMICOLON 
-- On ELSIF reduce production stmt -> IDENT LPAR separated_nonempty_list(COMMA,expr) RPAR SEMICOLON 
-- On ELSE reduce production stmt -> IDENT LPAR separated_nonempty_list(COMMA,expr) RPAR SEMICOLON 
-- On CHARVAL reduce production stmt -> IDENT LPAR separated_nonempty_list(COMMA,expr) RPAR SEMICOLON 
-- On CHAR reduce production stmt -> IDENT LPAR separated_nonempty_list(COMMA,expr) RPAR SEMICOLON 
-- On BEGIN reduce production stmt -> IDENT LPAR separated_nonempty_list(COMMA,expr) RPAR SEMICOLON 

State 141:
stmt -> FOR . IDENT IN option(REVERSE) expr DOUBLEDOT expr LOOP nonempty_list(stmt) END LOOP SEMICOLON [ WHILE TRUE SUB RETURN NULL NOT NEW LPAR INT IF IDENT FOR FALSE END ELSIF ELSE CHARVAL CHAR BEGIN ]
-- On IDENT shift to state 142

State 142:
stmt -> FOR IDENT . IN option(REVERSE) expr DOUBLEDOT expr LOOP nonempty_list(stmt) END LOOP SEMICOLON [ WHILE TRUE SUB RETURN NULL NOT NEW LPAR INT IF IDENT FOR FALSE END ELSIF ELSE CHARVAL CHAR BEGIN ]
-- On IN shift to state 143

State 143:
stmt -> FOR IDENT IN . option(REVERSE) expr DOUBLEDOT expr LOOP nonempty_list(stmt) END LOOP SEMICOLON [ WHILE TRUE SUB RETURN NULL NOT NEW LPAR INT IF IDENT FOR FALSE END ELSIF ELSE CHARVAL CHAR BEGIN ]
-- On REVERSE shift to state 144
-- On option(REVERSE) shift to state 145
-- On TRUE reduce production option(REVERSE) -> 
-- On SUB reduce production option(REVERSE) -> 
-- On NULL reduce production option(REVERSE) -> 
-- On NOT reduce production option(REVERSE) -> 
-- On NEW reduce production option(REVERSE) -> 
-- On LPAR reduce production option(REVERSE) -> 
-- On INT reduce production option(REVERSE) -> 
-- On IDENT reduce production option(REVERSE) -> 
-- On FALSE reduce production option(REVERSE) -> 
-- On CHARVAL reduce production option(REVERSE) -> 
-- On CHAR reduce production option(REVERSE) -> 

State 144:
option(REVERSE) -> REVERSE . [ TRUE SUB NULL NOT NEW LPAR INT IDENT FALSE CHARVAL CHAR ]
-- On TRUE reduce production option(REVERSE) -> REVERSE 
-- On SUB reduce production option(REVERSE) -> REVERSE 
-- On NULL reduce production option(REVERSE) -> REVERSE 
-- On NOT reduce production option(REVERSE) -> REVERSE 
-- On NEW reduce production option(REVERSE) -> REVERSE 
-- On LPAR reduce production option(REVERSE) -> REVERSE 
-- On INT reduce production option(REVERSE) -> REVERSE 
-- On IDENT reduce production option(REVERSE) -> REVERSE 
-- On FALSE reduce production option(REVERSE) -> REVERSE 
-- On CHARVAL reduce production option(REVERSE) -> REVERSE 
-- On CHAR reduce production option(REVERSE) -> REVERSE 

State 145:
stmt -> FOR IDENT IN option(REVERSE) . expr DOUBLEDOT expr LOOP nonempty_list(stmt) END LOOP SEMICOLON [ WHILE TRUE SUB RETURN NULL NOT NEW LPAR INT IF IDENT FOR FALSE END ELSIF ELSE CHARVAL CHAR BEGIN ]
-- On TRUE shift to state 63
-- On SUB shift to state 64
-- On NULL shift to state 65
-- On NOT shift to state 66
-- On NEW shift to state 67
-- On LPAR shift to state 69
-- On INT shift to state 70
-- On IDENT shift to state 71
-- On FALSE shift to state 73
-- On CHARVAL shift to state 74
-- On CHAR shift to state 76
-- On expr shift to state 146
-- On access shift to state 84

State 146:
access -> expr . DOT IDENT [ SUB REM OR NEQ MUL LT LE GT GE EQ DOUBLEDOT DOT DIV AND ADD ]
expr -> expr . AND THEN expr [ SUB REM OR NEQ MUL LT LE GT GE EQ DOUBLEDOT DOT DIV AND ADD ]
expr -> expr . OR ELSE expr [ SUB REM OR NEQ MUL LT LE GT GE EQ DOUBLEDOT DOT DIV AND ADD ]
expr -> expr . EQ expr [ SUB REM OR NEQ MUL LT LE GT GE EQ DOUBLEDOT DOT DIV AND ADD ]
expr -> expr . NEQ expr [ SUB REM OR NEQ MUL LT LE GT GE EQ DOUBLEDOT DOT DIV AND ADD ]
expr -> expr . LT expr [ SUB REM OR NEQ MUL LT LE GT GE EQ DOUBLEDOT DOT DIV AND ADD ]
expr -> expr . LE expr [ SUB REM OR NEQ MUL LT LE GT GE EQ DOUBLEDOT DOT DIV AND ADD ]
expr -> expr . GT expr [ SUB REM OR NEQ MUL LT LE GT GE EQ DOUBLEDOT DOT DIV AND ADD ]
expr -> expr . GE expr [ SUB REM OR NEQ MUL LT LE GT GE EQ DOUBLEDOT DOT DIV AND ADD ]
expr -> expr . ADD expr [ SUB REM OR NEQ MUL LT LE GT GE EQ DOUBLEDOT DOT DIV AND ADD ]
expr -> expr . SUB expr [ SUB REM OR NEQ MUL LT LE GT GE EQ DOUBLEDOT DOT DIV AND ADD ]
expr -> expr . MUL expr [ SUB REM OR NEQ MUL LT LE GT GE EQ DOUBLEDOT DOT DIV AND ADD ]
expr -> expr . DIV expr [ SUB REM OR NEQ MUL LT LE GT GE EQ DOUBLEDOT DOT DIV AND ADD ]
expr -> expr . REM expr [ SUB REM OR NEQ MUL LT LE GT GE EQ DOUBLEDOT DOT DIV AND ADD ]
expr -> expr . AND expr [ SUB REM OR NEQ MUL LT LE GT GE EQ DOUBLEDOT DOT DIV AND ADD ]
expr -> expr . OR expr [ SUB REM OR NEQ MUL LT LE GT GE EQ DOUBLEDOT DOT DIV AND ADD ]
stmt -> FOR IDENT IN option(REVERSE) expr . DOUBLEDOT expr LOOP nonempty_list(stmt) END LOOP SEMICOLON [ WHILE TRUE SUB RETURN NULL NOT NEW LPAR INT IF IDENT FOR FALSE END ELSIF ELSE CHARVAL CHAR BEGIN ]
-- On SUB shift to state 78
-- On REM shift to state 80
-- On OR shift to state 90
-- On NEQ shift to state 93
-- On MUL shift to state 85
-- On LT shift to state 95
-- On LE shift to state 99
-- On GT shift to state 101
-- On GE shift to state 103
-- On EQ shift to state 105
-- On DOUBLEDOT shift to state 147
-- On DOT shift to state 82
-- On DIV shift to state 87
-- On AND shift to state 107
-- On ADD shift to state 97

State 147:
stmt -> FOR IDENT IN option(REVERSE) expr DOUBLEDOT . expr LOOP nonempty_list(stmt) END LOOP SEMICOLON [ WHILE TRUE SUB RETURN NULL NOT NEW LPAR INT IF IDENT FOR FALSE END ELSIF ELSE CHARVAL CHAR BEGIN ]
-- On TRUE shift to state 63
-- On SUB shift to state 64
-- On NULL shift to state 65
-- On NOT shift to state 66
-- On NEW shift to state 67
-- On LPAR shift to state 69
-- On INT shift to state 70
-- On IDENT shift to state 71
-- On FALSE shift to state 73
-- On CHARVAL shift to state 74
-- On CHAR shift to state 76
-- On expr shift to state 148
-- On access shift to state 84

State 148:
access -> expr . DOT IDENT [ SUB REM OR NEQ MUL LT LOOP LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . AND THEN expr [ SUB REM OR NEQ MUL LT LOOP LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . OR ELSE expr [ SUB REM OR NEQ MUL LT LOOP LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . EQ expr [ SUB REM OR NEQ MUL LT LOOP LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . NEQ expr [ SUB REM OR NEQ MUL LT LOOP LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . LT expr [ SUB REM OR NEQ MUL LT LOOP LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . LE expr [ SUB REM OR NEQ MUL LT LOOP LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . GT expr [ SUB REM OR NEQ MUL LT LOOP LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . GE expr [ SUB REM OR NEQ MUL LT LOOP LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . ADD expr [ SUB REM OR NEQ MUL LT LOOP LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . SUB expr [ SUB REM OR NEQ MUL LT LOOP LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . MUL expr [ SUB REM OR NEQ MUL LT LOOP LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . DIV expr [ SUB REM OR NEQ MUL LT LOOP LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . REM expr [ SUB REM OR NEQ MUL LT LOOP LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . AND expr [ SUB REM OR NEQ MUL LT LOOP LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . OR expr [ SUB REM OR NEQ MUL LT LOOP LE GT GE EQ DOT DIV AND ADD ]
stmt -> FOR IDENT IN option(REVERSE) expr DOUBLEDOT expr . LOOP nonempty_list(stmt) END LOOP SEMICOLON [ WHILE TRUE SUB RETURN NULL NOT NEW LPAR INT IF IDENT FOR FALSE END ELSIF ELSE CHARVAL CHAR BEGIN ]
-- On SUB shift to state 78
-- On REM shift to state 80
-- On OR shift to state 90
-- On NEQ shift to state 93
-- On MUL shift to state 85
-- On LT shift to state 95
-- On LOOP shift to state 149
-- On LE shift to state 99
-- On GT shift to state 101
-- On GE shift to state 103
-- On EQ shift to state 105
-- On DOT shift to state 82
-- On DIV shift to state 87
-- On AND shift to state 107
-- On ADD shift to state 97

State 149:
stmt -> FOR IDENT IN option(REVERSE) expr DOUBLEDOT expr LOOP . nonempty_list(stmt) END LOOP SEMICOLON [ WHILE TRUE SUB RETURN NULL NOT NEW LPAR INT IF IDENT FOR FALSE END ELSIF ELSE CHARVAL CHAR BEGIN ]
-- On WHILE shift to state 125
-- On TRUE shift to state 63
-- On SUB shift to state 64
-- On RETURN shift to state 128
-- On NULL shift to state 65
-- On NOT shift to state 66
-- On NEW shift to state 67
-- On LPAR shift to state 69
-- On INT shift to state 70
-- On IF shift to state 132
-- On IDENT shift to state 135
-- On FOR shift to state 141
-- On FALSE shift to state 73
-- On CHARVAL shift to state 74
-- On CHAR shift to state 76
-- On BEGIN shift to state 150
-- On stmt shift to state 151
-- On nonempty_list(stmt) shift to state 161
-- On expr shift to state 153
-- On access shift to state 154

State 150:
stmt -> BEGIN . nonempty_list(stmt) END SEMICOLON [ WHILE TRUE SUB RETURN NULL NOT NEW LPAR INT IF IDENT FOR FALSE END ELSIF ELSE CHARVAL CHAR BEGIN ]
-- On WHILE shift to state 125
-- On TRUE shift to state 63
-- On SUB shift to state 64
-- On RETURN shift to state 128
-- On NULL shift to state 65
-- On NOT shift to state 66
-- On NEW shift to state 67
-- On LPAR shift to state 69
-- On INT shift to state 70
-- On IF shift to state 132
-- On IDENT shift to state 135
-- On FOR shift to state 141
-- On FALSE shift to state 73
-- On CHARVAL shift to state 74
-- On CHAR shift to state 76
-- On BEGIN shift to state 150
-- On stmt shift to state 151
-- On nonempty_list(stmt) shift to state 158
-- On expr shift to state 153
-- On access shift to state 154

State 151:
nonempty_list(stmt) -> stmt . [ END ELSIF ELSE ]
nonempty_list(stmt) -> stmt . nonempty_list(stmt) [ END ELSIF ELSE ]
-- On WHILE shift to state 125
-- On TRUE shift to state 63
-- On SUB shift to state 64
-- On RETURN shift to state 128
-- On NULL shift to state 65
-- On NOT shift to state 66
-- On NEW shift to state 67
-- On LPAR shift to state 69
-- On INT shift to state 70
-- On IF shift to state 132
-- On IDENT shift to state 135
-- On FOR shift to state 141
-- On FALSE shift to state 73
-- On CHARVAL shift to state 74
-- On CHAR shift to state 76
-- On BEGIN shift to state 150
-- On stmt shift to state 151
-- On nonempty_list(stmt) shift to state 152
-- On expr shift to state 153
-- On access shift to state 154
-- On END reduce production nonempty_list(stmt) -> stmt 
-- On ELSIF reduce production nonempty_list(stmt) -> stmt 
-- On ELSE reduce production nonempty_list(stmt) -> stmt 

State 152:
nonempty_list(stmt) -> stmt nonempty_list(stmt) . [ END ELSIF ELSE ]
-- On END reduce production nonempty_list(stmt) -> stmt nonempty_list(stmt) 
-- On ELSIF reduce production nonempty_list(stmt) -> stmt nonempty_list(stmt) 
-- On ELSE reduce production nonempty_list(stmt) -> stmt nonempty_list(stmt) 

State 153:
access -> expr . DOT IDENT [ SUB REM OR NEQ MUL LT LE GT GE EQ DOT DIV COLONEQ AND ADD ]
expr -> expr . AND THEN expr [ SUB REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . OR ELSE expr [ SUB REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . EQ expr [ SUB REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . NEQ expr [ SUB REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . LT expr [ SUB REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . LE expr [ SUB REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . GT expr [ SUB REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . GE expr [ SUB REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . ADD expr [ SUB REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . SUB expr [ SUB REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . MUL expr [ SUB REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . DIV expr [ SUB REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . REM expr [ SUB REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . AND expr [ SUB REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . OR expr [ SUB REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
-- On SUB shift to state 78
-- On REM shift to state 80
-- On OR shift to state 90
-- On NEQ shift to state 93
-- On MUL shift to state 85
-- On LT shift to state 95
-- On LE shift to state 99
-- On GT shift to state 101
-- On GE shift to state 103
-- On EQ shift to state 105
-- On DOT shift to state 82
-- On DIV shift to state 87
-- On AND shift to state 107
-- On ADD shift to state 97

State 154:
expr -> access . [ SUB REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
stmt -> access . COLONEQ expr SEMICOLON [ WHILE TRUE SUB RETURN NULL NOT NEW LPAR INT IF IDENT FOR FALSE END ELSIF ELSE CHARVAL CHAR BEGIN ]
-- On COLONEQ shift to state 155
-- On SUB reduce production expr -> access 
-- On REM reduce production expr -> access 
-- On OR reduce production expr -> access 
-- On NEQ reduce production expr -> access 
-- On MUL reduce production expr -> access 
-- On LT reduce production expr -> access 
-- On LE reduce production expr -> access 
-- On GT reduce production expr -> access 
-- On GE reduce production expr -> access 
-- On EQ reduce production expr -> access 
-- On DOT reduce production expr -> access 
-- On DIV reduce production expr -> access 
-- On AND reduce production expr -> access 
-- On ADD reduce production expr -> access 

State 155:
stmt -> access COLONEQ . expr SEMICOLON [ WHILE TRUE SUB RETURN NULL NOT NEW LPAR INT IF IDENT FOR FALSE END ELSIF ELSE CHARVAL CHAR BEGIN ]
-- On TRUE shift to state 63
-- On SUB shift to state 64
-- On NULL shift to state 65
-- On NOT shift to state 66
-- On NEW shift to state 67
-- On LPAR shift to state 69
-- On INT shift to state 70
-- On IDENT shift to state 71
-- On FALSE shift to state 73
-- On CHARVAL shift to state 74
-- On CHAR shift to state 76
-- On expr shift to state 156
-- On access shift to state 84

State 156:
access -> expr . DOT IDENT [ SUB SEMICOLON REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . AND THEN expr [ SUB SEMICOLON REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . OR ELSE expr [ SUB SEMICOLON REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . EQ expr [ SUB SEMICOLON REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . NEQ expr [ SUB SEMICOLON REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . LT expr [ SUB SEMICOLON REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . LE expr [ SUB SEMICOLON REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . GT expr [ SUB SEMICOLON REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . GE expr [ SUB SEMICOLON REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . ADD expr [ SUB SEMICOLON REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . SUB expr [ SUB SEMICOLON REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . MUL expr [ SUB SEMICOLON REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . DIV expr [ SUB SEMICOLON REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . REM expr [ SUB SEMICOLON REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . AND expr [ SUB SEMICOLON REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . OR expr [ SUB SEMICOLON REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
stmt -> access COLONEQ expr . SEMICOLON [ WHILE TRUE SUB RETURN NULL NOT NEW LPAR INT IF IDENT FOR FALSE END ELSIF ELSE CHARVAL CHAR BEGIN ]
-- On SUB shift to state 78
-- On SEMICOLON shift to state 157
-- On REM shift to state 80
-- On OR shift to state 90
-- On NEQ shift to state 93
-- On MUL shift to state 85
-- On LT shift to state 95
-- On LE shift to state 99
-- On GT shift to state 101
-- On GE shift to state 103
-- On EQ shift to state 105
-- On DOT shift to state 82
-- On DIV shift to state 87
-- On AND shift to state 107
-- On ADD shift to state 97

State 157:
stmt -> access COLONEQ expr SEMICOLON . [ WHILE TRUE SUB RETURN NULL NOT NEW LPAR INT IF IDENT FOR FALSE END ELSIF ELSE CHARVAL CHAR BEGIN ]
-- On WHILE reduce production stmt -> access COLONEQ expr SEMICOLON 
-- On TRUE reduce production stmt -> access COLONEQ expr SEMICOLON 
-- On SUB reduce production stmt -> access COLONEQ expr SEMICOLON 
-- On RETURN reduce production stmt -> access COLONEQ expr SEMICOLON 
-- On NULL reduce production stmt -> access COLONEQ expr SEMICOLON 
-- On NOT reduce production stmt -> access COLONEQ expr SEMICOLON 
-- On NEW reduce production stmt -> access COLONEQ expr SEMICOLON 
-- On LPAR reduce production stmt -> access COLONEQ expr SEMICOLON 
-- On INT reduce production stmt -> access COLONEQ expr SEMICOLON 
-- On IF reduce production stmt -> access COLONEQ expr SEMICOLON 
-- On IDENT reduce production stmt -> access COLONEQ expr SEMICOLON 
-- On FOR reduce production stmt -> access COLONEQ expr SEMICOLON 
-- On FALSE reduce production stmt -> access COLONEQ expr SEMICOLON 
-- On END reduce production stmt -> access COLONEQ expr SEMICOLON 
-- On ELSIF reduce production stmt -> access COLONEQ expr SEMICOLON 
-- On ELSE reduce production stmt -> access COLONEQ expr SEMICOLON 
-- On CHARVAL reduce production stmt -> access COLONEQ expr SEMICOLON 
-- On CHAR reduce production stmt -> access COLONEQ expr SEMICOLON 
-- On BEGIN reduce production stmt -> access COLONEQ expr SEMICOLON 

State 158:
stmt -> BEGIN nonempty_list(stmt) . END SEMICOLON [ WHILE TRUE SUB RETURN NULL NOT NEW LPAR INT IF IDENT FOR FALSE END ELSIF ELSE CHARVAL CHAR BEGIN ]
-- On END shift to state 159

State 159:
stmt -> BEGIN nonempty_list(stmt) END . SEMICOLON [ WHILE TRUE SUB RETURN NULL NOT NEW LPAR INT IF IDENT FOR FALSE END ELSIF ELSE CHARVAL CHAR BEGIN ]
-- On SEMICOLON shift to state 160

State 160:
stmt -> BEGIN nonempty_list(stmt) END SEMICOLON . [ WHILE TRUE SUB RETURN NULL NOT NEW LPAR INT IF IDENT FOR FALSE END ELSIF ELSE CHARVAL CHAR BEGIN ]
-- On WHILE reduce production stmt -> BEGIN nonempty_list(stmt) END SEMICOLON 
-- On TRUE reduce production stmt -> BEGIN nonempty_list(stmt) END SEMICOLON 
-- On SUB reduce production stmt -> BEGIN nonempty_list(stmt) END SEMICOLON 
-- On RETURN reduce production stmt -> BEGIN nonempty_list(stmt) END SEMICOLON 
-- On NULL reduce production stmt -> BEGIN nonempty_list(stmt) END SEMICOLON 
-- On NOT reduce production stmt -> BEGIN nonempty_list(stmt) END SEMICOLON 
-- On NEW reduce production stmt -> BEGIN nonempty_list(stmt) END SEMICOLON 
-- On LPAR reduce production stmt -> BEGIN nonempty_list(stmt) END SEMICOLON 
-- On INT reduce production stmt -> BEGIN nonempty_list(stmt) END SEMICOLON 
-- On IF reduce production stmt -> BEGIN nonempty_list(stmt) END SEMICOLON 
-- On IDENT reduce production stmt -> BEGIN nonempty_list(stmt) END SEMICOLON 
-- On FOR reduce production stmt -> BEGIN nonempty_list(stmt) END SEMICOLON 
-- On FALSE reduce production stmt -> BEGIN nonempty_list(stmt) END SEMICOLON 
-- On END reduce production stmt -> BEGIN nonempty_list(stmt) END SEMICOLON 
-- On ELSIF reduce production stmt -> BEGIN nonempty_list(stmt) END SEMICOLON 
-- On ELSE reduce production stmt -> BEGIN nonempty_list(stmt) END SEMICOLON 
-- On CHARVAL reduce production stmt -> BEGIN nonempty_list(stmt) END SEMICOLON 
-- On CHAR reduce production stmt -> BEGIN nonempty_list(stmt) END SEMICOLON 
-- On BEGIN reduce production stmt -> BEGIN nonempty_list(stmt) END SEMICOLON 

State 161:
stmt -> FOR IDENT IN option(REVERSE) expr DOUBLEDOT expr LOOP nonempty_list(stmt) . END LOOP SEMICOLON [ WHILE TRUE SUB RETURN NULL NOT NEW LPAR INT IF IDENT FOR FALSE END ELSIF ELSE CHARVAL CHAR BEGIN ]
-- On END shift to state 162

State 162:
stmt -> FOR IDENT IN option(REVERSE) expr DOUBLEDOT expr LOOP nonempty_list(stmt) END . LOOP SEMICOLON [ WHILE TRUE SUB RETURN NULL NOT NEW LPAR INT IF IDENT FOR FALSE END ELSIF ELSE CHARVAL CHAR BEGIN ]
-- On LOOP shift to state 163

State 163:
stmt -> FOR IDENT IN option(REVERSE) expr DOUBLEDOT expr LOOP nonempty_list(stmt) END LOOP . SEMICOLON [ WHILE TRUE SUB RETURN NULL NOT NEW LPAR INT IF IDENT FOR FALSE END ELSIF ELSE CHARVAL CHAR BEGIN ]
-- On SEMICOLON shift to state 164

State 164:
stmt -> FOR IDENT IN option(REVERSE) expr DOUBLEDOT expr LOOP nonempty_list(stmt) END LOOP SEMICOLON . [ WHILE TRUE SUB RETURN NULL NOT NEW LPAR INT IF IDENT FOR FALSE END ELSIF ELSE CHARVAL CHAR BEGIN ]
-- On WHILE reduce production stmt -> FOR IDENT IN option(REVERSE) expr DOUBLEDOT expr LOOP nonempty_list(stmt) END LOOP SEMICOLON 
-- On TRUE reduce production stmt -> FOR IDENT IN option(REVERSE) expr DOUBLEDOT expr LOOP nonempty_list(stmt) END LOOP SEMICOLON 
-- On SUB reduce production stmt -> FOR IDENT IN option(REVERSE) expr DOUBLEDOT expr LOOP nonempty_list(stmt) END LOOP SEMICOLON 
-- On RETURN reduce production stmt -> FOR IDENT IN option(REVERSE) expr DOUBLEDOT expr LOOP nonempty_list(stmt) END LOOP SEMICOLON 
-- On NULL reduce production stmt -> FOR IDENT IN option(REVERSE) expr DOUBLEDOT expr LOOP nonempty_list(stmt) END LOOP SEMICOLON 
-- On NOT reduce production stmt -> FOR IDENT IN option(REVERSE) expr DOUBLEDOT expr LOOP nonempty_list(stmt) END LOOP SEMICOLON 
-- On NEW reduce production stmt -> FOR IDENT IN option(REVERSE) expr DOUBLEDOT expr LOOP nonempty_list(stmt) END LOOP SEMICOLON 
-- On LPAR reduce production stmt -> FOR IDENT IN option(REVERSE) expr DOUBLEDOT expr LOOP nonempty_list(stmt) END LOOP SEMICOLON 
-- On INT reduce production stmt -> FOR IDENT IN option(REVERSE) expr DOUBLEDOT expr LOOP nonempty_list(stmt) END LOOP SEMICOLON 
-- On IF reduce production stmt -> FOR IDENT IN option(REVERSE) expr DOUBLEDOT expr LOOP nonempty_list(stmt) END LOOP SEMICOLON 
-- On IDENT reduce production stmt -> FOR IDENT IN option(REVERSE) expr DOUBLEDOT expr LOOP nonempty_list(stmt) END LOOP SEMICOLON 
-- On FOR reduce production stmt -> FOR IDENT IN option(REVERSE) expr DOUBLEDOT expr LOOP nonempty_list(stmt) END LOOP SEMICOLON 
-- On FALSE reduce production stmt -> FOR IDENT IN option(REVERSE) expr DOUBLEDOT expr LOOP nonempty_list(stmt) END LOOP SEMICOLON 
-- On END reduce production stmt -> FOR IDENT IN option(REVERSE) expr DOUBLEDOT expr LOOP nonempty_list(stmt) END LOOP SEMICOLON 
-- On ELSIF reduce production stmt -> FOR IDENT IN option(REVERSE) expr DOUBLEDOT expr LOOP nonempty_list(stmt) END LOOP SEMICOLON 
-- On ELSE reduce production stmt -> FOR IDENT IN option(REVERSE) expr DOUBLEDOT expr LOOP nonempty_list(stmt) END LOOP SEMICOLON 
-- On CHARVAL reduce production stmt -> FOR IDENT IN option(REVERSE) expr DOUBLEDOT expr LOOP nonempty_list(stmt) END LOOP SEMICOLON 
-- On CHAR reduce production stmt -> FOR IDENT IN option(REVERSE) expr DOUBLEDOT expr LOOP nonempty_list(stmt) END LOOP SEMICOLON 
-- On BEGIN reduce production stmt -> FOR IDENT IN option(REVERSE) expr DOUBLEDOT expr LOOP nonempty_list(stmt) END LOOP SEMICOLON 

State 165:
stmt -> IF expr THEN nonempty_list(stmt) . condition [ WHILE TRUE SUB RETURN NULL NOT NEW LPAR INT IF IDENT FOR FALSE END ELSIF ELSE CHARVAL CHAR BEGIN ]
-- On END shift to state 166
-- On ELSIF shift to state 169
-- On ELSE shift to state 173
-- On condition shift to state 179

State 166:
condition -> END . IF SEMICOLON [ WHILE TRUE SUB RETURN NULL NOT NEW LPAR INT IF IDENT FOR FALSE END ELSIF ELSE CHARVAL CHAR BEGIN ]
-- On IF shift to state 167

State 167:
condition -> END IF . SEMICOLON [ WHILE TRUE SUB RETURN NULL NOT NEW LPAR INT IF IDENT FOR FALSE END ELSIF ELSE CHARVAL CHAR BEGIN ]
-- On SEMICOLON shift to state 168

State 168:
condition -> END IF SEMICOLON . [ WHILE TRUE SUB RETURN NULL NOT NEW LPAR INT IF IDENT FOR FALSE END ELSIF ELSE CHARVAL CHAR BEGIN ]
-- On WHILE reduce production condition -> END IF SEMICOLON 
-- On TRUE reduce production condition -> END IF SEMICOLON 
-- On SUB reduce production condition -> END IF SEMICOLON 
-- On RETURN reduce production condition -> END IF SEMICOLON 
-- On NULL reduce production condition -> END IF SEMICOLON 
-- On NOT reduce production condition -> END IF SEMICOLON 
-- On NEW reduce production condition -> END IF SEMICOLON 
-- On LPAR reduce production condition -> END IF SEMICOLON 
-- On INT reduce production condition -> END IF SEMICOLON 
-- On IF reduce production condition -> END IF SEMICOLON 
-- On IDENT reduce production condition -> END IF SEMICOLON 
-- On FOR reduce production condition -> END IF SEMICOLON 
-- On FALSE reduce production condition -> END IF SEMICOLON 
-- On END reduce production condition -> END IF SEMICOLON 
-- On ELSIF reduce production condition -> END IF SEMICOLON 
-- On ELSE reduce production condition -> END IF SEMICOLON 
-- On CHARVAL reduce production condition -> END IF SEMICOLON 
-- On CHAR reduce production condition -> END IF SEMICOLON 
-- On BEGIN reduce production condition -> END IF SEMICOLON 

State 169:
condition -> ELSIF . expr THEN nonempty_list(stmt) condition [ WHILE TRUE SUB RETURN NULL NOT NEW LPAR INT IF IDENT FOR FALSE END ELSIF ELSE CHARVAL CHAR BEGIN ]
-- On TRUE shift to state 63
-- On SUB shift to state 64
-- On NULL shift to state 65
-- On NOT shift to state 66
-- On NEW shift to state 67
-- On LPAR shift to state 69
-- On INT shift to state 70
-- On IDENT shift to state 71
-- On FALSE shift to state 73
-- On CHARVAL shift to state 74
-- On CHAR shift to state 76
-- On expr shift to state 170
-- On access shift to state 84

State 170:
access -> expr . DOT IDENT [ THEN SUB REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
condition -> ELSIF expr . THEN nonempty_list(stmt) condition [ WHILE TRUE SUB RETURN NULL NOT NEW LPAR INT IF IDENT FOR FALSE END ELSIF ELSE CHARVAL CHAR BEGIN ]
expr -> expr . AND THEN expr [ THEN SUB REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . OR ELSE expr [ THEN SUB REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . EQ expr [ THEN SUB REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . NEQ expr [ THEN SUB REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . LT expr [ THEN SUB REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . LE expr [ THEN SUB REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . GT expr [ THEN SUB REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . GE expr [ THEN SUB REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . ADD expr [ THEN SUB REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . SUB expr [ THEN SUB REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . MUL expr [ THEN SUB REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . DIV expr [ THEN SUB REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . REM expr [ THEN SUB REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . AND expr [ THEN SUB REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
expr -> expr . OR expr [ THEN SUB REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD ]
-- On THEN shift to state 171
-- On SUB shift to state 78
-- On REM shift to state 80
-- On OR shift to state 90
-- On NEQ shift to state 93
-- On MUL shift to state 85
-- On LT shift to state 95
-- On LE shift to state 99
-- On GT shift to state 101
-- On GE shift to state 103
-- On EQ shift to state 105
-- On DOT shift to state 82
-- On DIV shift to state 87
-- On AND shift to state 107
-- On ADD shift to state 97

State 171:
condition -> ELSIF expr THEN . nonempty_list(stmt) condition [ WHILE TRUE SUB RETURN NULL NOT NEW LPAR INT IF IDENT FOR FALSE END ELSIF ELSE CHARVAL CHAR BEGIN ]
-- On WHILE shift to state 125
-- On TRUE shift to state 63
-- On SUB shift to state 64
-- On RETURN shift to state 128
-- On NULL shift to state 65
-- On NOT shift to state 66
-- On NEW shift to state 67
-- On LPAR shift to state 69
-- On INT shift to state 70
-- On IF shift to state 132
-- On IDENT shift to state 135
-- On FOR shift to state 141
-- On FALSE shift to state 73
-- On CHARVAL shift to state 74
-- On CHAR shift to state 76
-- On BEGIN shift to state 150
-- On stmt shift to state 151
-- On nonempty_list(stmt) shift to state 172
-- On expr shift to state 153
-- On access shift to state 154

State 172:
condition -> ELSIF expr THEN nonempty_list(stmt) . condition [ WHILE TRUE SUB RETURN NULL NOT NEW LPAR INT IF IDENT FOR FALSE END ELSIF ELSE CHARVAL CHAR BEGIN ]
-- On END shift to state 166
-- On ELSIF shift to state 169
-- On ELSE shift to state 173
-- On condition shift to state 178

State 173:
condition -> ELSE . nonempty_list(stmt) END IF SEMICOLON [ WHILE TRUE SUB RETURN NULL NOT NEW LPAR INT IF IDENT FOR FALSE END ELSIF ELSE CHARVAL CHAR BEGIN ]
-- On WHILE shift to state 125
-- On TRUE shift to state 63
-- On SUB shift to state 64
-- On RETURN shift to state 128
-- On NULL shift to state 65
-- On NOT shift to state 66
-- On NEW shift to state 67
-- On LPAR shift to state 69
-- On INT shift to state 70
-- On IF shift to state 132
-- On IDENT shift to state 135
-- On FOR shift to state 141
-- On FALSE shift to state 73
-- On CHARVAL shift to state 74
-- On CHAR shift to state 76
-- On BEGIN shift to state 150
-- On stmt shift to state 151
-- On nonempty_list(stmt) shift to state 174
-- On expr shift to state 153
-- On access shift to state 154

State 174:
condition -> ELSE nonempty_list(stmt) . END IF SEMICOLON [ WHILE TRUE SUB RETURN NULL NOT NEW LPAR INT IF IDENT FOR FALSE END ELSIF ELSE CHARVAL CHAR BEGIN ]
-- On END shift to state 175

State 175:
condition -> ELSE nonempty_list(stmt) END . IF SEMICOLON [ WHILE TRUE SUB RETURN NULL NOT NEW LPAR INT IF IDENT FOR FALSE END ELSIF ELSE CHARVAL CHAR BEGIN ]
-- On IF shift to state 176

State 176:
condition -> ELSE nonempty_list(stmt) END IF . SEMICOLON [ WHILE TRUE SUB RETURN NULL NOT NEW LPAR INT IF IDENT FOR FALSE END ELSIF ELSE CHARVAL CHAR BEGIN ]
-- On SEMICOLON shift to state 177

State 177:
condition -> ELSE nonempty_list(stmt) END IF SEMICOLON . [ WHILE TRUE SUB RETURN NULL NOT NEW LPAR INT IF IDENT FOR FALSE END ELSIF ELSE CHARVAL CHAR BEGIN ]
-- On WHILE reduce production condition -> ELSE nonempty_list(stmt) END IF SEMICOLON 
-- On TRUE reduce production condition -> ELSE nonempty_list(stmt) END IF SEMICOLON 
-- On SUB reduce production condition -> ELSE nonempty_list(stmt) END IF SEMICOLON 
-- On RETURN reduce production condition -> ELSE nonempty_list(stmt) END IF SEMICOLON 
-- On NULL reduce production condition -> ELSE nonempty_list(stmt) END IF SEMICOLON 
-- On NOT reduce production condition -> ELSE nonempty_list(stmt) END IF SEMICOLON 
-- On NEW reduce production condition -> ELSE nonempty_list(stmt) END IF SEMICOLON 
-- On LPAR reduce production condition -> ELSE nonempty_list(stmt) END IF SEMICOLON 
-- On INT reduce production condition -> ELSE nonempty_list(stmt) END IF SEMICOLON 
-- On IF reduce production condition -> ELSE nonempty_list(stmt) END IF SEMICOLON 
-- On IDENT reduce production condition -> ELSE nonempty_list(stmt) END IF SEMICOLON 
-- On FOR reduce production condition -> ELSE nonempty_list(stmt) END IF SEMICOLON 
-- On FALSE reduce production condition -> ELSE nonempty_list(stmt) END IF SEMICOLON 
-- On END reduce production condition -> ELSE nonempty_list(stmt) END IF SEMICOLON 
-- On ELSIF reduce production condition -> ELSE nonempty_list(stmt) END IF SEMICOLON 
-- On ELSE reduce production condition -> ELSE nonempty_list(stmt) END IF SEMICOLON 
-- On CHARVAL reduce production condition -> ELSE nonempty_list(stmt) END IF SEMICOLON 
-- On CHAR reduce production condition -> ELSE nonempty_list(stmt) END IF SEMICOLON 
-- On BEGIN reduce production condition -> ELSE nonempty_list(stmt) END IF SEMICOLON 

State 178:
condition -> ELSIF expr THEN nonempty_list(stmt) condition . [ WHILE TRUE SUB RETURN NULL NOT NEW LPAR INT IF IDENT FOR FALSE END ELSIF ELSE CHARVAL CHAR BEGIN ]
-- On WHILE reduce production condition -> ELSIF expr THEN nonempty_list(stmt) condition 
-- On TRUE reduce production condition -> ELSIF expr THEN nonempty_list(stmt) condition 
-- On SUB reduce production condition -> ELSIF expr THEN nonempty_list(stmt) condition 
-- On RETURN reduce production condition -> ELSIF expr THEN nonempty_list(stmt) condition 
-- On NULL reduce production condition -> ELSIF expr THEN nonempty_list(stmt) condition 
-- On NOT reduce production condition -> ELSIF expr THEN nonempty_list(stmt) condition 
-- On NEW reduce production condition -> ELSIF expr THEN nonempty_list(stmt) condition 
-- On LPAR reduce production condition -> ELSIF expr THEN nonempty_list(stmt) condition 
-- On INT reduce production condition -> ELSIF expr THEN nonempty_list(stmt) condition 
-- On IF reduce production condition -> ELSIF expr THEN nonempty_list(stmt) condition 
-- On IDENT reduce production condition -> ELSIF expr THEN nonempty_list(stmt) condition 
-- On FOR reduce production condition -> ELSIF expr THEN nonempty_list(stmt) condition 
-- On FALSE reduce production condition -> ELSIF expr THEN nonempty_list(stmt) condition 
-- On END reduce production condition -> ELSIF expr THEN nonempty_list(stmt) condition 
-- On ELSIF reduce production condition -> ELSIF expr THEN nonempty_list(stmt) condition 
-- On ELSE reduce production condition -> ELSIF expr THEN nonempty_list(stmt) condition 
-- On CHARVAL reduce production condition -> ELSIF expr THEN nonempty_list(stmt) condition 
-- On CHAR reduce production condition -> ELSIF expr THEN nonempty_list(stmt) condition 
-- On BEGIN reduce production condition -> ELSIF expr THEN nonempty_list(stmt) condition 

State 179:
stmt -> IF expr THEN nonempty_list(stmt) condition . [ WHILE TRUE SUB RETURN NULL NOT NEW LPAR INT IF IDENT FOR FALSE END ELSIF ELSE CHARVAL CHAR BEGIN ]
-- On WHILE reduce production stmt -> IF expr THEN nonempty_list(stmt) condition 
-- On TRUE reduce production stmt -> IF expr THEN nonempty_list(stmt) condition 
-- On SUB reduce production stmt -> IF expr THEN nonempty_list(stmt) condition 
-- On RETURN reduce production stmt -> IF expr THEN nonempty_list(stmt) condition 
-- On NULL reduce production stmt -> IF expr THEN nonempty_list(stmt) condition 
-- On NOT reduce production stmt -> IF expr THEN nonempty_list(stmt) condition 
-- On NEW reduce production stmt -> IF expr THEN nonempty_list(stmt) condition 
-- On LPAR reduce production stmt -> IF expr THEN nonempty_list(stmt) condition 
-- On INT reduce production stmt -> IF expr THEN nonempty_list(stmt) condition 
-- On IF reduce production stmt -> IF expr THEN nonempty_list(stmt) condition 
-- On IDENT reduce production stmt -> IF expr THEN nonempty_list(stmt) condition 
-- On FOR reduce production stmt -> IF expr THEN nonempty_list(stmt) condition 
-- On FALSE reduce production stmt -> IF expr THEN nonempty_list(stmt) condition 
-- On END reduce production stmt -> IF expr THEN nonempty_list(stmt) condition 
-- On ELSIF reduce production stmt -> IF expr THEN nonempty_list(stmt) condition 
-- On ELSE reduce production stmt -> IF expr THEN nonempty_list(stmt) condition 
-- On CHARVAL reduce production stmt -> IF expr THEN nonempty_list(stmt) condition 
-- On CHAR reduce production stmt -> IF expr THEN nonempty_list(stmt) condition 
-- On BEGIN reduce production stmt -> IF expr THEN nonempty_list(stmt) condition 

State 180:
stmt -> WHILE expr LOOP nonempty_list(stmt) . END LOOP SEMICOLON [ WHILE TRUE SUB RETURN NULL NOT NEW LPAR INT IF IDENT FOR FALSE END ELSIF ELSE CHARVAL CHAR BEGIN ]
-- On END shift to state 181

State 181:
stmt -> WHILE expr LOOP nonempty_list(stmt) END . LOOP SEMICOLON [ WHILE TRUE SUB RETURN NULL NOT NEW LPAR INT IF IDENT FOR FALSE END ELSIF ELSE CHARVAL CHAR BEGIN ]
-- On LOOP shift to state 182

State 182:
stmt -> WHILE expr LOOP nonempty_list(stmt) END LOOP . SEMICOLON [ WHILE TRUE SUB RETURN NULL NOT NEW LPAR INT IF IDENT FOR FALSE END ELSIF ELSE CHARVAL CHAR BEGIN ]
-- On SEMICOLON shift to state 183

State 183:
stmt -> WHILE expr LOOP nonempty_list(stmt) END LOOP SEMICOLON . [ WHILE TRUE SUB RETURN NULL NOT NEW LPAR INT IF IDENT FOR FALSE END ELSIF ELSE CHARVAL CHAR BEGIN ]
-- On WHILE reduce production stmt -> WHILE expr LOOP nonempty_list(stmt) END LOOP SEMICOLON 
-- On TRUE reduce production stmt -> WHILE expr LOOP nonempty_list(stmt) END LOOP SEMICOLON 
-- On SUB reduce production stmt -> WHILE expr LOOP nonempty_list(stmt) END LOOP SEMICOLON 
-- On RETURN reduce production stmt -> WHILE expr LOOP nonempty_list(stmt) END LOOP SEMICOLON 
-- On NULL reduce production stmt -> WHILE expr LOOP nonempty_list(stmt) END LOOP SEMICOLON 
-- On NOT reduce production stmt -> WHILE expr LOOP nonempty_list(stmt) END LOOP SEMICOLON 
-- On NEW reduce production stmt -> WHILE expr LOOP nonempty_list(stmt) END LOOP SEMICOLON 
-- On LPAR reduce production stmt -> WHILE expr LOOP nonempty_list(stmt) END LOOP SEMICOLON 
-- On INT reduce production stmt -> WHILE expr LOOP nonempty_list(stmt) END LOOP SEMICOLON 
-- On IF reduce production stmt -> WHILE expr LOOP nonempty_list(stmt) END LOOP SEMICOLON 
-- On IDENT reduce production stmt -> WHILE expr LOOP nonempty_list(stmt) END LOOP SEMICOLON 
-- On FOR reduce production stmt -> WHILE expr LOOP nonempty_list(stmt) END LOOP SEMICOLON 
-- On FALSE reduce production stmt -> WHILE expr LOOP nonempty_list(stmt) END LOOP SEMICOLON 
-- On END reduce production stmt -> WHILE expr LOOP nonempty_list(stmt) END LOOP SEMICOLON 
-- On ELSIF reduce production stmt -> WHILE expr LOOP nonempty_list(stmt) END LOOP SEMICOLON 
-- On ELSE reduce production stmt -> WHILE expr LOOP nonempty_list(stmt) END LOOP SEMICOLON 
-- On CHARVAL reduce production stmt -> WHILE expr LOOP nonempty_list(stmt) END LOOP SEMICOLON 
-- On CHAR reduce production stmt -> WHILE expr LOOP nonempty_list(stmt) END LOOP SEMICOLON 
-- On BEGIN reduce production stmt -> WHILE expr LOOP nonempty_list(stmt) END LOOP SEMICOLON 

State 184:
decl -> FUNCTION IDENT option(params) RETURN stype IS list(decl) BEGIN nonempty_list(stmt) . END option(IDENT) SEMICOLON [ TYPE PROCEDURE IDENT FUNCTION BEGIN ]
-- On END shift to state 185

State 185:
decl -> FUNCTION IDENT option(params) RETURN stype IS list(decl) BEGIN nonempty_list(stmt) END . option(IDENT) SEMICOLON [ TYPE PROCEDURE IDENT FUNCTION BEGIN ]
-- On IDENT shift to state 186
-- On option(IDENT) shift to state 187
-- On SEMICOLON reduce production option(IDENT) -> 

State 186:
option(IDENT) -> IDENT . [ SEMICOLON ]
-- On SEMICOLON reduce production option(IDENT) -> IDENT 

State 187:
decl -> FUNCTION IDENT option(params) RETURN stype IS list(decl) BEGIN nonempty_list(stmt) END option(IDENT) . SEMICOLON [ TYPE PROCEDURE IDENT FUNCTION BEGIN ]
-- On SEMICOLON shift to state 188

State 188:
decl -> FUNCTION IDENT option(params) RETURN stype IS list(decl) BEGIN nonempty_list(stmt) END option(IDENT) SEMICOLON . [ TYPE PROCEDURE IDENT FUNCTION BEGIN ]
-- On TYPE reduce production decl -> FUNCTION IDENT option(params) RETURN stype IS list(decl) BEGIN nonempty_list(stmt) END option(IDENT) SEMICOLON 
-- On PROCEDURE reduce production decl -> FUNCTION IDENT option(params) RETURN stype IS list(decl) BEGIN nonempty_list(stmt) END option(IDENT) SEMICOLON 
-- On IDENT reduce production decl -> FUNCTION IDENT option(params) RETURN stype IS list(decl) BEGIN nonempty_list(stmt) END option(IDENT) SEMICOLON 
-- On FUNCTION reduce production decl -> FUNCTION IDENT option(params) RETURN stype IS list(decl) BEGIN nonempty_list(stmt) END option(IDENT) SEMICOLON 
-- On BEGIN reduce production decl -> FUNCTION IDENT option(params) RETURN stype IS list(decl) BEGIN nonempty_list(stmt) END option(IDENT) SEMICOLON 

State 189:
list(decl) -> decl . list(decl) [ BEGIN ]
-- On TYPE shift to state 10
-- On PROCEDURE shift to state 34
-- On IDENT shift to state 15
-- On FUNCTION shift to state 52
-- On separated_nonempty_list(COMMA,IDENT) shift to state 58
-- On list(decl) shift to state 190
-- On decl shift to state 189
-- On BEGIN reduce production list(decl) -> 

State 190:
list(decl) -> decl list(decl) . [ BEGIN ]
-- On BEGIN reduce production list(decl) -> decl list(decl) 

State 191:
decl -> PROCEDURE IDENT option(params) IS list(decl) . BEGIN nonempty_list(stmt) END option(IDENT) SEMICOLON [ TYPE PROCEDURE IDENT FUNCTION BEGIN ]
-- On BEGIN shift to state 192

State 192:
decl -> PROCEDURE IDENT option(params) IS list(decl) BEGIN . nonempty_list(stmt) END option(IDENT) SEMICOLON [ TYPE PROCEDURE IDENT FUNCTION BEGIN ]
-- On WHILE shift to state 125
-- On TRUE shift to state 63
-- On SUB shift to state 64
-- On RETURN shift to state 128
-- On NULL shift to state 65
-- On NOT shift to state 66
-- On NEW shift to state 67
-- On LPAR shift to state 69
-- On INT shift to state 70
-- On IF shift to state 132
-- On IDENT shift to state 135
-- On FOR shift to state 141
-- On FALSE shift to state 73
-- On CHARVAL shift to state 74
-- On CHAR shift to state 76
-- On BEGIN shift to state 150
-- On stmt shift to state 151
-- On nonempty_list(stmt) shift to state 193
-- On expr shift to state 153
-- On access shift to state 154

State 193:
decl -> PROCEDURE IDENT option(params) IS list(decl) BEGIN nonempty_list(stmt) . END option(IDENT) SEMICOLON [ TYPE PROCEDURE IDENT FUNCTION BEGIN ]
-- On END shift to state 194

State 194:
decl -> PROCEDURE IDENT option(params) IS list(decl) BEGIN nonempty_list(stmt) END . option(IDENT) SEMICOLON [ TYPE PROCEDURE IDENT FUNCTION BEGIN ]
-- On IDENT shift to state 186
-- On option(IDENT) shift to state 195
-- On SEMICOLON reduce production option(IDENT) -> 

State 195:
decl -> PROCEDURE IDENT option(params) IS list(decl) BEGIN nonempty_list(stmt) END option(IDENT) . SEMICOLON [ TYPE PROCEDURE IDENT FUNCTION BEGIN ]
-- On SEMICOLON shift to state 196

State 196:
decl -> PROCEDURE IDENT option(params) IS list(decl) BEGIN nonempty_list(stmt) END option(IDENT) SEMICOLON . [ TYPE PROCEDURE IDENT FUNCTION BEGIN ]
-- On TYPE reduce production decl -> PROCEDURE IDENT option(params) IS list(decl) BEGIN nonempty_list(stmt) END option(IDENT) SEMICOLON 
-- On PROCEDURE reduce production decl -> PROCEDURE IDENT option(params) IS list(decl) BEGIN nonempty_list(stmt) END option(IDENT) SEMICOLON 
-- On IDENT reduce production decl -> PROCEDURE IDENT option(params) IS list(decl) BEGIN nonempty_list(stmt) END option(IDENT) SEMICOLON 
-- On FUNCTION reduce production decl -> PROCEDURE IDENT option(params) IS list(decl) BEGIN nonempty_list(stmt) END option(IDENT) SEMICOLON 
-- On BEGIN reduce production decl -> PROCEDURE IDENT option(params) IS list(decl) BEGIN nonempty_list(stmt) END option(IDENT) SEMICOLON 

State 197:
file -> WITH STDLIB SEMICOLON USE STDLIB SEMICOLON PROCEDURE IDENT IS list(decl) . BEGIN nonempty_list(stmt) END option(IDENT) SEMICOLON EOF [ # ]
-- On BEGIN shift to state 198

State 198:
file -> WITH STDLIB SEMICOLON USE STDLIB SEMICOLON PROCEDURE IDENT IS list(decl) BEGIN . nonempty_list(stmt) END option(IDENT) SEMICOLON EOF [ # ]
-- On WHILE shift to state 125
-- On TRUE shift to state 63
-- On SUB shift to state 64
-- On RETURN shift to state 128
-- On NULL shift to state 65
-- On NOT shift to state 66
-- On NEW shift to state 67
-- On LPAR shift to state 69
-- On INT shift to state 70
-- On IF shift to state 132
-- On IDENT shift to state 135
-- On FOR shift to state 141
-- On FALSE shift to state 73
-- On CHARVAL shift to state 74
-- On CHAR shift to state 76
-- On BEGIN shift to state 150
-- On stmt shift to state 151
-- On nonempty_list(stmt) shift to state 199
-- On expr shift to state 153
-- On access shift to state 154

State 199:
file -> WITH STDLIB SEMICOLON USE STDLIB SEMICOLON PROCEDURE IDENT IS list(decl) BEGIN nonempty_list(stmt) . END option(IDENT) SEMICOLON EOF [ # ]
-- On END shift to state 200

State 200:
file -> WITH STDLIB SEMICOLON USE STDLIB SEMICOLON PROCEDURE IDENT IS list(decl) BEGIN nonempty_list(stmt) END . option(IDENT) SEMICOLON EOF [ # ]
-- On IDENT shift to state 186
-- On option(IDENT) shift to state 201
-- On SEMICOLON reduce production option(IDENT) -> 

State 201:
file -> WITH STDLIB SEMICOLON USE STDLIB SEMICOLON PROCEDURE IDENT IS list(decl) BEGIN nonempty_list(stmt) END option(IDENT) . SEMICOLON EOF [ # ]
-- On SEMICOLON shift to state 202

State 202:
file -> WITH STDLIB SEMICOLON USE STDLIB SEMICOLON PROCEDURE IDENT IS list(decl) BEGIN nonempty_list(stmt) END option(IDENT) SEMICOLON . EOF [ # ]
-- On EOF shift to state 203

State 203:
file -> WITH STDLIB SEMICOLON USE STDLIB SEMICOLON PROCEDURE IDENT IS list(decl) BEGIN nonempty_list(stmt) END option(IDENT) SEMICOLON EOF . [ # ]
-- On # reduce production file -> WITH STDLIB SEMICOLON USE STDLIB SEMICOLON PROCEDURE IDENT IS list(decl) BEGIN nonempty_list(stmt) END option(IDENT) SEMICOLON EOF 

State 204:
file' -> file . [ # ]
-- On # accept file

